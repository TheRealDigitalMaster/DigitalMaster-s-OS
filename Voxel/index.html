<!--
    Aug 2019
    v3.7.7 beta 2022
    @nimadez

    # Voxel Builder
    # Voxel-based 3D modeling application

    [ Code Map ]
    01. Initialize
    02. Scene
    03. Material
    04. Builder (SPS voxels)
    05. Layer (color palette)
    06. Helper (overlays)
    07. Tool
    08. Memory
    09. Symmetry
    10. Bakery (baked meshes)
    11. Voxelizer
    12. HQRender (pipeline)
    13. Projects
    14. Storage
    15. Generator
    16. UserInterface
    17. UserInterfaceAdvanced
    18. Events
    19. Utils
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Voxel-based 3D modeling application">
    <meta name="author" content="@nimadez">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@nimadez">
    <meta name="twitter:creator" content="@nimadez">
    <meta name="twitter:title" content="Voxel Builder">
    <meta name="twitter:description" content="Voxel-based 3D modeling application">
    <meta name="twitter:image" content="https://nimadez.github.io/voxel-builder/media/banner.jpg">
    <title>Voxel Builder</title>
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" href="data:image/png;base64,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">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" rel="preload">
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        @font-face {
            font-family: 'DroidSans'; src: url(data:font/truetype;charset=utf-8;base64,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FSERIQEhESMGVv0I/iXLugKPA8n9wwIW/eoCPft1AZNsAcX+OwW2pP48ov34AcYCqAAAAP//AH3+FASYBcsSJgAmAAARBwB6AfwAAAALtgFPKiQYICUBKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAQ/+3AVIAFbQBDAUmAbj/wrQSDAEAJQErNQArNQD//wDHAAADvgdzEiYAKAAAEQcAdgA/AVIAE0ALARgFJgFKDBIBACUBKzUAKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAw//xAVIAFbQBDAUmAbj//bQUDAEAJQErNQArNQD//wDHAAADvgcrEiYAKAAAEQcAav/1AVIAF0ANAgEVBSYCAQEMIAEAJQErNTUAKzU1AAAA//8APgAAAmQHcxImACwAABEHAEP+tQFSABW0AQwFJgG4/6i0EgwBACUBKzUAKzUA//8AUgAAAooHcxImACwAABEHAHb/eAFSABNACwEYBSYBagwSAQAlASs1ACs1AAAA//8AEQAAAqkHcxImACwAABEHAMP/DwFSABNACwEMBSYBAhQMAQAlASs1ACs1AAAA//8AQAAAAncHKxImACwAABEHAGr/DQFSABdADQIBFQUmAgEADCABACUBKzU1ACs1NQAAAAACAC8AAAT8BbYAEAAfAF1AOhoaDhFbCGchICEBGBxaDhAQAQ5kIBsQXxgPAAEPAD8AbwCvAN8A/wAGCABAGh1IAAACHGAOEhdgAgMAP+E/4RE5LyteXXEz4TIBEOYyMi8Q4TJdEPbhETkvMTATMxEhMh4BEhUUAgYEIyERIyU0LgIrAREhFSERMyAAL5gBl5n4rl9gtv73qP6SmAQIQn64dckBUP6wogEIAQwDJQKRXLX+9LC5/um7XgKDYJLVikP+DqL+HQEk//8AxwAABQ4HNRImADEAABEHAMUAiwFSABNACwEgBSYBCiEvCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAEMAVAFSABW0AigFJgK4/6u0LigKACUBKzUAKzUA//8Aff/sBXEHcxImADIAABEHAHYBAgFSABNACwI0BSYCWCguCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAMMArgFSABNACwIoBSYCBTAoCgAlASs1ACs1AAAA//8Aff/sBXEHNRImADIAABEHAMUAfQFS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b3B5cmlnaHQgqSAyMDA3LCBHb29nbGUgQ29ycG9yYXRpb24uAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABBAHMAYwBlAG4AZABlAHIAIAAtACAARAByAG8AaQBkACAAUwBhAG4AcwAAQXNjZW5kZXIgLSBEcm9pZCBTYW5zAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAgAGIAdQBpAGwAZAAgADEAMQAzAABWZXJzaW9uIDEuMDAgYnVpbGQgMTEzAABEAHIAbwBpAGQAUwBhAG4AcwAARHJvaWRTYW5zAABEAHIAbwBpAGQAIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABHAG8AbwBnAGwAZQAgAGEAbgBkACAAbQBhAHkAIABiAGUAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAYwBlAHIAdABhAGkAbgAgAGoAdQByAGkAcwBkAGkAYwB0AGkAbwBuAHMALgAARHJvaWQgaXMgYSB0cmFkZW1hcmsgb2YgR29vZ2xlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuAABBAHMAYwBlAG4AZABlAHIAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4AAEFzY2VuZGVyIENvcnBvcmF0aW9uAABEAHIAbwBpAGQAIABTAGEAbgBzACAAaQBzACAAYQAgAGgAdQBtAGEAbgBpAHMAdAAgAHMAYQBuAHMAIABzAGUAcgBpAGYAIAB0AHkAcABlAGYAYQBjAGUAIABkAGUAcwBpAGcAbgBlAGQAIABmAG8AcgAgAHUAcwBlAHIAIABpAG4AdABlAHIAZgBhAGMAZQBzACAAYQBuAGQAIABlAGwAZQBjAHQAcgBvAG4AaQBjACAAYwBvAG0AbQB1AG4AaQBjAGEAdABpAG8AbgAuAABEcm9pZCBTYW5zIGlzIGEgaHVtYW5pc3Qgc2FucyBzZXJpZiB0eXBlZmFjZSBkZXNpZ25lZCBmb3IgdXNlciBpbnRlcmZhY2VzIGFuZCBlbGVjdHJvbmljIGNvbW11bmljYXRp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AEAAKQBgACkAif/XAJT/1wCV/9cAlv/XAJf/1wCY/9cAmv/XAMkAKQDMACkAFgAP/8MAEf/DACT/7AAs/+wAN//DADn/7AA6/+wAO//sADz/1wA9/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAiP/DAI7/7ACP/+wAkP/sAJH/7ACf/9cAFgAFAD0ACgA9AAwAKQAP/5oAEf+aACIAKQAk/9cAOQAUADoAFAA8ABQAQAApAGAAKQCC/9cAg//XAIT/1wCF/9cAhv/XAIf/1wCI/8MAnwAUAMkAPQDMAD0ADwAFACkACgApACb/7AAq/+wAMv/sADT/7ACJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAyQApAMwAKQAPAAUAKQAKACkAJv/XACr/1wAy/9cANP/XAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wDJACkAzAApABkABf+aAAr/mgAm/+wAKv/sADL/7AA0/+wAN/+FADj/7AA5/64AOv/DADz/mgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAm//sAJz/7ACd/+wAnv/sAJ//mgDJ/5oAzP+aABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCO/+wAj//sAJD/7ACR/+wAn//XABAAD/8zABH/MwAk/64AJv/sADv/7AA8/+wAPf/XAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/cQCJ/+wAn//sABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/wwCO/+wAj//sAJD/7ACR/+wAn//XAAEAN//sAEoABQBSAAoAUgAP/5oAEP+aABH/mgAiACkAJP+FACb/wwAq/8MAMv/DADT/wwA2/+wANwAUAET/hQBG/4UAR/+FAEj/hQBK/5oAUP+uAFH/rgBS/4UAU/+uAFT/hQBV/64AVv+FAFj/rgBZ/8MAWv/DAFv/wwBc/8MAXf/DAIL/hQCD/4UAhP+FAIX/hQCG/4UAh/+FAIj/cQCJ/8MAlP/DAJX/wwCW/8MAl//DAJj/wwCa/8MAov+FAKP/hQCk/4UApf+FAKb/hQCn/4UAqP+FAKn/hQCq/4UAq/+FAKz/hQCt/4UAs/+uALT/hQC1/4UAtv+FALf/hQC4/4UAuv+FALv/rgC8/64Avf+uAL7/rgC//8MAwf/DAMb/rgDH/5oAyQBSAMwAUgAKAA//1wAR/9cAJP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wA+AAUAUgAKAFIAD/+aABH/mgAiACkAJP/DACb/1wAq/9cAMv/XADT/1wBE/8MARv/DAEf/wwBI/8MASv/DAFD/1wBR/9cAUv/DAFP/1wBU/8MAVf/XAFb/1wBY/9cAgv/DAIP/wwCE/8MAhf/DAIb/wwCH/8MAiP+FAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/8MAo//DAKT/wwCl/8MApv/DAKf/wwCo/8MAqf/DAKr/wwCr/8MArP/DAK3/wwCz/9cAtP/DALX/wwC2/8MAt//DALj/wwC6/8MAu//XALz/1wC9/9cAvv/XAMkAUgDMAFIAPgAFAGYACgBmAA//rgAR/64AJP/XACb/7AAq/+wAMv/sADT/7ABE/9cARv/XAEf/1wBI/9cASv/sAFD/7ABR/+wAUv/XAFP/7ABU/9cAVf/sAFb/1wBY/+wAXf/sAIL/1wCD/9cAhP/XAIX/1wCG/9cAh//XAIj/rgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAov/XAKP/1wCk/9cApf/XAKb/1wCn/9cAqP/XAKn/1wCq/9cAq//XAKz/1wCt/9cAs//sALT/1wC1/9cAtv/XALf/1wC4/9cAuv/XALv/7AC8/+wAvf/sAL7/7ADJAGYAzABmACAABQApAAoAKQAm/9cAKv/XADL/1wA0/9cARv/sAEf/7ABI/+wAUv/sAFT/7ACJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAqP/sAKn/7ACq/+wAq//sAKz/7ACt/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAyQApAMwAKQBEAAUAUgAKAFIAD/+aABH/mgAiACkAJP+aACb/1wAq/9cAMv/XADT/1wA2/+wARP+aAEb/mgBH/5oASP+aAEr/mgBQ/8MAUf/DAFL/mgBT/8MAVP+aAFX/wwBW/64AWP/DAFv/1wBc/+wAXf/DAIL/mgCD/5oAhP+aAIX/mgCG/5oAh/+aAIj/cQCJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAov+aAKP/mgCk/5oApf+aAKb/mgCn/5oAqP+aAKn/mgCq/5oAq/+aAKz/mgCt/5oAs//DALT/mgC1/5oAtv+aALf/mgC4/5oAuv+aALv/wwC8/8MAvf/DAL7/wwC//+wAwf/sAMkAUgDMAFIAAQAK/9cABAAFAD0ACgA9AMkAPQDMAD0ACQAFAGYACgBmAFkAFABaABQAXAAUAL8AFADBABQAyQBmAMwAZgAFAAUAKQAKACkASgAUAMkAKQDMACkAAQAK/8MABAAFACkACgApAMkAKQDMACkAAgBb/9cAXf/sAAwABQBmAAoAZgBE/+wASv/sAKL/7ACj/+wApP/sAKX/7ACm/+wAp//sAMkAZgDMAGYABQAFAFIACgBSAFcAFADJAFIAzABSAAUABQBSAAoAUgBJABQAyQBSAMwAUgAMAAUAKQAKACkAUv/XAKj/1wC0/9cAtf/XALb/1wC3/9cAuP/XALr/1wDJACkAzAApAAUABQA9AAoAPQBJABQAyQA9AMwAPQAIAFL/7ACo/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAJwAF/64ACv+uAA3/hQAPAEQAHgBEACL/wwAm/+wAKv/sAC0AXgAy/+wANP/sADf/hQA4/+wAOf/DADr/1wA8/5oAPQA7AEn/7ABX/+wAWf/XAFr/7ABc/9cAgv/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf+FAA8ARAAeAEQAIv/DACb/7AAq/+wAMv/sADT/7AA3/4UAOP/sADn/wwA6/9cAPP+aAD0AOwBJ/+wAV//sAFn/1wBa/+wAXP/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyf+uAMz/rgAnAAX/ZgAK/2YADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyP9mAMn/rgDL/2YAzP+uABIABQApAAoAKQAQ/9cAJv/sADL/7AA0/+wAhP/sAIn/7ACK/+wAj//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkAEAAFACkACgApABD/1wAm/+wAMv/sADT/7ACJ/+wAi//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkABwAk/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAGwAM/9cAD//DABH/wwAk/+wALP/sAC3/9gA2/+wAN//DADn/1wA6/+wAO//XADz/1wA9/+wAQP/XAGD/1wCC/+wAg//sAIT/7ACF/+wAhv/sAIf/7ACI/9cAjv/sAI//7ACQ/+wAkf/sAJ//1wATAA//1wAR/9cAJP/sADD/7AA9/+wARP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCi/+wAo//sAKT/7ACl/+wApv/sAKf/7ABSAAUAUgAJ/8MACgBSAAwAPQANACkAD/+aABD/mgAR/5oAIgApACT/mgAm/9cAKv/XAC3/vgAw/8MAMv/XADT/1wA2/+wANwAnADkAKQA6ABQAQAA9AET/mgBG/5oAR/+aAEj/mgBJ/+UASv+aAFD/wwBR/8MAUv+aAFP/wwBU/5oAVf/DAFb/rgBY/8MAWf/XAFr/7ABb/9cAXP/sAF3/wwBgAD0Agv+aAIP/mgCE/5oAhf+aAIb/mgCH/5oAiP9xAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/5oAo/+aAKT/mgCl/5oApv+aAKf/mgCo/5oAqf+aAKr/mgCr/5oArP+aAK3/mgCz/8MAtP+aALX/mgC2/5oAt/+aALj/mgC6/5oAu//DALz/wwC9/8MAvv/DAL//7ADB/+wAyQBSAMwAUgACAAX/mAAK/9cAAwAF/5gACv/XAMz/1wAFAAX/bwAK/28ASf/bAFv/1wBd/+wAAgAF/74ACv++AB4ABQA9AAoAPQAP/74AEf++ACL/tABG//YAR//2AEj/9gBJABQASv/2AFL/9gBU//YAVwAGAKj/9gCp//YAqv/2AKv/9gCs//YArf/2ALT/9gC1//YAtv/2ALf/9gC4//YAuv/2AMkAPQDK/40AzAA9AM3/jQDQAAwABwAFAD0ACgA9AA//vgAR/74ASQAUAMkAPQDMAD0AKQAk/64ALAApADcAUgA5AFIAOgBmADsAKQA8AFIAPQApAEb/wwBH/8MASP/DAEr/1wBS/8MAVP/DAFcAKQBZACkAWgAUAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/XACOACkAjwApAJAAKQCRACkAnwBSAKj/wwCp/8MAqv/DAKv/wwCs/8MArf/DALT/wwC1/8MAtv/DALf/wwC4/8MAuv/DAAIAGQAFAAUAAAAKAAsAAQAPABEAAwAkACcABgApACkACgAsACwACwAuAC8ADAAyADUADgA3AD4AEgBEAEYAGgBIAEsAHQBOAE4AIQBQAFIAIgBVAFcAJQBZAF4AKACCAIcALgCJAJIANACUAJgAPgCaAJ8AQwCiAK0ASQCzALgAVQC6AL8AWwDBAMEAYQDGAMgAYgDLAMsAZQABAAAACgAcAB4AAWxhdG4ACAAEAAAAAP//AAAAAAAA)
                format('truetype');
        }
        * { margin: 0; padding: 0; outline: none; }
        html, body { overscroll-behavior-y: contain; user-select: none; overflow: hidden; touch-action: pan-x; -webkit-tap-highlight-color: transparent; } /* prevent pull-down refresh and text selection on chrome mobile + prevent forced scroll + blue tap highlight on touch */
        body { background: white; font-family: 'DroidSans'; font-size: 11px; color: #aaa; position: fixed; width: 100%; height: 100%; cursor: default; }
        canvas { z-index: 0; position: absolute; width: 100%; height: 100%; background: radial-gradient(circle, #586277 0%, #3f4657 100%); }
        a { color: #6a8cad; text-decoration: none; }
        a:hover { color: orange; text-decoration: none; }
        input[type=number] { width: 40px; margin: 1px 0 1px 0; background: #222833; color: #97a5b8; padding: 3px; font-size: 11px; text-indent: 1px; border: solid 1px #343c49; border-radius: 2px; text-align: left; }
        input[type=number]:hover { color: #0097cc; border: solid 1px #43495a; }
        input[type=range] { width: 55px; height: 5px; filter: hue-rotate(330deg) saturate(1.3); }
        input[type=range]::-webkit-slider-thumb { transform: scale(0.8); }
        input[type=range]::-webkit-slider-thumb:hover { cursor: pointer; }
        input[type=checkbox] { transform: scale(0.8); vertical-align: text-bottom; filter: hue-rotate(15deg) contrast(1) brightness(1) invert(); }
        input[type=color] { width: 20px; height: 20px; border: none; background: #2e35414d; outline: none; border: none; border-radius: 100%; vertical-align: text-bottom; }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type=color]::-webkit-color-swatch { border: none; border-radius: 3px; border: solid 1px #444; }
        input[type=color]:hover { background: white; cursor: pointer; }
        ul { position: absolute; list-style-type: none; }
        ul li { background: #2d3644; border: 1px solid #161a2096; border-radius: 3px; padding: 2px; text-align: center; }
        ul li:hover, .tool_selector { background: orange; color: #222; }
        ul li.spacer { height: 2px; }
        button { width: 32px; background: #2d3644; color: #98a1ac; box-shadow: inset 1px 1px 0 #2d3644, inset -1px -1px 0 #2d3644; border-radius: 3px; padding: 3px; line-height: 1.2em; border: 1px solid #161a2080; }
        button:hover, .toggle_hq { background: orange; color: #222; cursor: pointer; }
        button:disabled { background: #2d3644; opacity: 0.5; pointer-events: none; }
        label { color: #7a828f; margin: 2px; font-size: 10px; }
        select { width: 85px; background: #2d3644; color: #aaa; font-size: 11px; padding: 1px; border: solid 1px #343c49; border-radius: 2px; outline: none; margin-left: 1px; vertical-align: middle; }
        select:hover { color: #0097cc; cursor: pointer; }
        option { color: silver; background: #252931; }
        .menu { z-index: 1000; position: absolute; top: 0; right: 0; background: #2a2f3af1; padding: 0 6px 6px 6px; width: 90px; height: fit-content; transform: translate(200px, 0); transition: transform 0.2s ease; box-shadow: -1px 1px 0 #5d697990; border-bottom-left-radius: 5px; }
        .menu li { background: none; color: #4b5669; text-align: left; border: none; padding: 0; cursor: default; }
        .menu li:hover { background: none; }
        .menu li i { color: #97a5b890; }
        .menu button { width: 100%; font-size: 11px; border-radius: 2px; }
        .menu .category { color: #51596b; background: #252833; font-size: 10px; font-weight: bold; letter-spacing: 1px; text-align: center; margin: 3px 0 3px 0; padding: 3px 0 3px 0; border-radius: 3px; }
        .menu .category:hover { color: #51596b; background: #252833; cursor: default; }
        .menu :first-child { cursor: pointer; }
        .menu li i:first-child { margin-top: 6px; }
        .menu li:hover i:first-child { color: orange; }
        #toolbar_C { z-index: 500; width: 300px; left: 50%; margin-left: -150px; top: 3px; text-align: center; }
        #toolbar_C li { display: inline-block; width: 18px; height: 11px; font-size: 9px; padding: 4px 0 3px 0; margin: 0 -2px 0 -2px; border-radius: 0; cursor: pointer; }
        #toolbar_C li.memory_select { background: #4e5c70; color: orange; }
        #toolbar_C .material-icons { font-size: 12px; margin-top: -1px; }
        #toolbar_C .mem { background: #38414e; }
        #toolbar_C .mem:hover { color: orange; }
        #toolbar_C .axis_select { width: 28px; color: orange; font-weight: bold; }
        #toolbar_C .axis_select:hover { background: #38414e; }
        #toolbar_C :first-child { border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C :last-child { border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_C :nth-child(1) { width: 30px; }
        #toolbar_C :nth-child(2) { width: 30px; }
        #toolbar_R { z-index: 500; position: absolute; right: 3px; top: 3px; }
        #toolbar_R li { background: none; border: none; padding: 0; margin-bottom: 2px; }
        #toolbar_L { z-index: 500; position: absolute; left: 3px; top: 3px; }
        #toolbar_L li { background: none; border: none; padding: 0; margin-bottom: 2px; }
        #toolbar_L li .txt { font-size: 9px; padding: 6px 0 6px 0; }
        #layer { z-index: 500; width: 40px; position: absolute; left: 3px; top: 90px; bottom: 130px; overflow-y: scroll; line-height: 0; }
        #layer li { z-index: 500; border: solid 1px #333; display: inline-block; width: 10px; height: 10px; border-radius: 0; }
        #layer li:hover { border: solid 1px orange; }
        #menulayer { z-index: 500; width: 100px; position: absolute; left: 50px; top: 90px; transform: translate(-200px, 0); transition: transform 0.2s ease; }
        #menulayer li { font-size: 11px; padding: 5px 0 5px 0; border-radius: 0; cursor: pointer; }
        #menulayer .category { color: #5e667a; background: #262a35; font-size: 9px; font-weight: bold; letter-spacing: 1px; margin: 0; padding: 6px 0 5px 0; border-radius: 0; }
        #menulayer .category:hover { color: #5e667a; background: #262a35; cursor: pointer; }
        #menulayer .horiz { padding: 0; background: #262a35; cursor: default; }
        #menulayer .horiz button { width: 32px; padding: 2px 0 2px 0; margin: 0 -1px 0 -1px; }
        #menulayer .material-icons { font-size: 16px; }
        #colorpicker { z-index: 500; position: absolute; width: 28px; left: 8px; bottom: 102px; }
        #hover { z-index: 600; opacity: 0.9; top: 100px; right: 180px; position: absolute; background: none; }
        #hover li { padding: 3px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; cursor: pointer; }
        #hover li:nth-child(1) { cursor: move; }
        #hover li:nth-child(2) { position: absolute; top: -112%; left: 0%; }
        #hover li:nth-child(3) { position: absolute; top: 0%; left: 112%; }
        #hover li:nth-child(4) { position: absolute; top: 0%; left: -112%; }
        #hover li:nth-child(5) { position: absolute; top: 112%; left: 0%; }
        #hover li:nth-child(6) { position: absolute; top: 112%; left: 112%; }
        #hover li:nth-child(7) { position: absolute; top: -112%; left: -112%; }
        #axisview { z-index: 100; background: #161a2030; bottom: 5px; right: 5px; width: 58px; height: 58px; border: 1px solid #161a2040; border-radius: 50%; box-shadow: inset 1px 1px 1px #454f5eE6, inset -1px -1px 1px #454f5eE6; }
        #axisview li { width: 14px; height: 14px; background: #161a2060; color: #6b7588; border: none; border-radius: 50%; padding: 2px; cursor: pointer; }
        #axisview li:nth-child(1) { position: absolute; top: -26%; right: 0%; }
        #axisview li:nth-child(2) { position: absolute; top: -35%; right: 45%; }
        #axisview li:nth-child(3) { position: absolute; top: -14%; right: 85%; }
        #axisview li:nth-child(4) { position: absolute; top: 25%; right: 104%; }
        #axisview li:nth-child(5) { position: absolute; top: 65%; right: 97%; }
        #axisview li i { font-size: 12px; vertical-align: text-bottom; }
        #axisview .toggle_axisview { background: orange; color: #222; cursor: pointer; }
        #axisview_hitbox { z-index: 500; position: absolute; width: 63px; height: 62px; bottom: 0; right: 0; border-top-left-radius: 50%; cursor: pointer; }
        #notifier { opacity: 0; transition: opacity 0.5s; background: #2d3644f1; color: orange; border: solid 1px #666; box-shadow: 0 0 2px #21262eE6; font-size: 10px; position: absolute; width: fit-content; left: 50%; top: 50%; margin-left: -200px; margin-top: -20px; padding: 4px 6px 4px 6px; letter-spacing: 1px; text-align: center; border-radius: 3px; }
        #notifier.fade { opacity: 1; }
        #info { position: absolute; width: 200px; bottom: 2px; left: 50%; margin-left: -100px; font-size: 8px; letter-spacing: 0.1em; color: #97a5b890; text-align: center; pointer-events: none; }
        #info span { color: #97a5b8; font-weight: bold; }
        #helpbtn { opacity: 0.5; color: #96b1cc; width: 20px; height: 20px; position: absolute; bottom: 4px; left: 100px; cursor: pointer; }
        #helpbtn :first-child { font-size: 14px; }
        #help { z-index: 600; background: #21262e; padding: 8px; border-radius: 3px; position: absolute; width: 300px; height: auto; left: 50%; bottom: -1000px; margin-left: -160px; transition: 0.5s; overflow: hidden; cursor: help; }
        #help .tip { color: #bbb; font-size: 11px; line-height: 1.4em; }
        #help .tip h1 { font-size: 11px; color: orange; letter-spacing: 1px; display: inline; overflow: hidden; }
        #help .tip b { color: #6a8cad; font-size: 11px; font-weight: bold; font-style: normal; }
        #about { z-index: 1000; display: none; font-size: 11px; letter-spacing: 0.1em; line-height: 1.5em; background: #262a36f6; color: silver; position: absolute; width: 200px; height: 190px; left: 50%; top: 50%; margin-left: -100px; margin-top: -95px; padding-bottom: 8px; border-radius: 3px; box-shadow: 0 0 5px #2d2f36; text-align: center; cursor: help; }
        #about h1 { color: white; font-size: 18px; padding: 5px; padding-bottom: 0; }
        #about i { color: orange; font-size: 30px; margin-top: 10px; }
        #about b { font-weight: normal; font-size: 10px; letter-spacing: 0.05em; }
        #about span { opacity: 0.6; font-size: 10px; position: absolute; top: 90px; left: 3px; width: 100%; text-align: center; }
        #about a { font-size: 10px; }
        #status { opacity: 1; font-size: 9px; letter-spacing: 0.1em; line-height: 1.3em; transition: opacity 0.5s; position: absolute; width: 200px; left: 50%; margin-left: -100px; bottom: 40px; text-align: center; pointer-events: none; }
        #status b { font-size: 10px; color: orange; }
        #babylonjsLoadingDiv { z-index: 2000; } /* override babylon.js css */
        .tooltip { display: none; }
        .warning { color: tomato; font-size: 9px; font-weight: bold; }
        .material-icons { font-size: 16px; pointer-events: none; vertical-align: middle; text-align: center; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: none; }
        ::-webkit-scrollbar-thumb { background: #353f4d; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: steelblue; }
    </style>
</head>
<body>
    <canvas ondrop="dropHandler(event)" ondragover="dragHandler(event)" ondragleave="dragLeaveHandler(event)"></canvas>
    <ul class="menu" id="menumain">
        <li onclick="ui.toggleMenuMain()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">FILE</li>
        <li title="New"><button onclick="newProject()">New</button></li>
        <li title="Load"><button onclick="document.getElementById('openfile_vox').click()">Load</button></li>
        <li title="Save"><button onclick="saveProject()">Save</button></li>
        <li title="Export"><button onclick="exportGLB(false)">Export</button></li>        
        <li class="category">SETTINGS</li>
        <li><label>Light</label> <input title="Light Angle" type="range" value="120" min="0" max="360" step="10" oninput="updateLightAngles(this.value)"></li>
        <li class="spacer"></li><li class="spacer"></li>
        <li><button title="Fullscreen" onclick="toggleFullscreen()">Fullscreen</button></li>
        <li><button title="Optimize" onclick="optimize()">Optimize</button></li>
        <li class="category">ADDONS</li>
        <li><button onclick="location.href='https://nimadez.github.io/voxel-builder/addons/vi2xel.html'">Vi2xel (mobile)</button></li>
        <li><button onclick="location.href='https://raw.githubusercontent.com/nimadez/voxel-builder/main/addons/blender-importer.py'">Blender Importer</button></li>
        <li class="category">HELP</li>
        <li><button onclick="ui.toggleTooltips()">Instructions</button></li>
        <li><button onclick="document.getElementById('about').style.display='unset'">About</button></li>
    </ul>
    <ul class="menu" id="menugenerator">
        <li onclick="ui.toggleMenuGenerator()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">SAMPLES</li>
        <li>
            <select title="Load Samples" onchange="loadFile(this.options[this.selectedIndex].value)">
                <option value="samples/default.vox">Default</option>
                <option value="samples/default_old.vox">Default (old)</option>
                <option value="samples/threeplane.vox">Three Plane</option>
                <option value="samples/teapot.vox">Teapot</option>
                <option value="samples/sphere.vox">Sphere</option>
                <option value="samples/babylon.vox">Babylon.js (2D)</option>
                <option value="samples/pixelmonk.vox">Pixel Monk (2D)</option>
            </select>
        </li>
        <li class="category">GRID</li>
        <li>
            <label>X&nbsp;</label> <input id="input-grid-x" type="number" value="4" min="3" max="100"><br>
            <label>Y&nbsp;</label> <input id="input-grid-y" type="number" value="4" min="1" max="100"><br>
            <label>Z&nbsp;</label> <input id="input-grid-z" type="number" value="4" min="3" max="100"><br>
            <button title="Create Grid/Plane" onclick="createGrid()">Grid / Plane</button>
        </li>
        <li class="category">TERRAIN</li>
        <li>
            <label>X&nbsp;</label> <input id="input-terrain-x" type="number" value="30" min="3" max="100"><br>
            <label>Y&nbsp;</label> <input id="input-terrain-y" type="number" value="5" min="1" max="20"><br>
            <label>Z&nbsp;</label> <input id="input-terrain-z" type="number" value="30" min="3" max="100"><br>
            <button title="Create Terrain" onclick="createTerrain()">Terrain</button>
        </li>
    </ul>
    <ul class="menu" id="menuvoxelizer">
        <li onclick="ui.toggleMenuVoxelizer()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">3D VOXELIZER</li>
        <li title="Voxelize Model"><button onclick="document.getElementById('openfile_obj').click()">Load Model</button></li>
        <li><label>Scale&nbsp;&nbsp;&nbsp;&nbsp;</label> <input type="number" id="input-voxelizer-scale" value="40" min="5" max="100"></li>
        <li><label>Density</label> <input type="number" id="input-voxelizer-density" value="10" min="1" max="100"></li>
        <li class="category">2D VOXELIZER</li>
        <li title="Voxelize Image"><button onclick="document.getElementById('openfile_img').click()">Load Image</button></li>
        <li title="Paste Base64 Image"><button onclick="pasteBase64Image()">Paste Base64</button></li>
        <li><label>Ratio</label> <input type="number" id="input-voxelizer-ratio" value="5.0" min="0.1" max="20" step="0.1"></li>
        <li title="Z is Up"><input type="checkbox" id="input-voxelizer-zup" checked><i class="material-icons"></i> <label for="input-voxelizer-zup">Z-Up</label></li>
    </ul>
    <ul class="menu" id="menusymmetry">
        <li onclick="ui.toggleMenuSymmetry()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">SYMMETRY</li>
        <li title="Symmetrize" onclick="symmetry.symmetrizeVoxelPositions(1)"><button>Symmetrize<br>Pos to Neg</button></li>
        <li title="Symmetrize" onclick="symmetry.symmetrizeVoxelPositions(-1)"><button>Symmetrize<br>Neg to Pos</button></li>
        <li title="Mirror" onclick="symmetry.mirrorVoxelPositions()"><button>Mirror</button></li>
    </ul>
    <ul class="menu" id="menubakery">
        <li onclick="ui.toggleMenuBakery()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">BAKERY</li>
        <li title="Bake"><button onclick="bakery.bakeToMesh()">Bake</button></li>
        <li class="category">SELECTED</li>
        <li title="Clone"><button onclick="bakery.cloneSelected()">Clone</button></li>
        <li title="Delete"><button onclick="bakery.deleteSelected()">Delete</button></li>
        <li class="category">ALL</li>
        <li title="Show"><button onclick="bakery.displayBakes(true)">Show</button></li>
        <li title="Hide"><button onclick="bakery.displayBakes(false)">Hide</button></li>
        <li title="Clear"><button onclick="bakery.clearBakes()">Clear</button></li>
        <li class="category">OUTPUT</li>
        <li title="Export Bakes"><button onclick="exportGLB(true)">Export Bakes</button></li>
    </ul>
    <ul id="menulayer">
        <li class="category" onclick="ui.toggleMenuLayer()">LAYER TOOLBOX</li>
        <li class="horiz">
            <button title="Hide Selected" onclick="layer.hideSelected()"><i class="material-icons">visibility_off</i></button>
            <button title="Show Selected" onclick="layer.showSelected()"><i class="material-icons">visibility</i></button>
            <button title="Tool: Hide By Pick" class="hidebypick" onclick="tool.toolSelector('hidebypick')"><i class="material-icons">ads_click</i></button>
        </li>
        <li onclick="layer.setAllLayersVisible()">Unhide All</li>
        <li onclick="layer.invertVisibility()">Invert Visibility</li>
        <li onclick="layer.deleteSelected()">Delete Selected</li>
        <li onclick="layer.deleteHidden()">Delete Hidden</li>
        <li onclick="layer.clearSelection()">Clear Selection</li>
    </ul>
    <ul id="toolbar_R">
        <li title="Main Menu"><button onclick="ui.toggleMenuMain()"><i class="material-icons">menu_open</i></button></li>
        <li title="Generator"><button onclick="ui.toggleMenuGenerator()"><i class="material-icons">add</i></button></li>
        <li title="Voxelizer"><button onclick="ui.toggleMenuVoxelizer()"><i class="material-icons">auto_fix_high</i></button></li>
        <li class="spacer"></li>
        <li title="Symmetry"><button onclick="ui.toggleMenuSymmetry()"><i class="material-icons">flip</i></button></li>
        <li title="Bakery"><button onclick="ui.toggleMenuBakery()"><i class="material-icons">science</i></button></li>
        <li class="spacer"></li>
        <li title="Frame Camera"><button onclick="frameCamera()"><i class="material-icons">filter_center_focus</i></button></li>
        <li title="Normalize Position"><button onclick="normalizeVoxelPositions(true);"><i class="material-icons">equalizer</i></button></li>
        <i class="tooltip"><h1>Right Menu (Main)</h1>
            <br><b>Main Menu</b> access projects, files and preferences
            <br><b>Voxelizer 3D</b> import OBJ, merge and voxelize meshes, higher SCALE equals more details, DENSITY is the number of points per triangle faces
            <br><b>Voxelizer 2D</b> import JPG/PNG/Base64, voxelize pixels, support transparent PNG (icon, logo etc.), higher RATIO equals to more voxels and more details
            <br><b>Generator</b> a menu for all the generators and samples
            <br><b>Symmetry</b> symmetrize and mirror voxels, the pivot is the mesh center, support hidden color layers
            <br><b>Bakery</b> bake to mesh, the baked mesh is not editable, may preview the output result, or collect variations before export to GLB, bakery respect the hidden color layers
            <br><b>Frame Camera</b> frame camera to fit the model
            <br><b>Normalize Position</b> move to center and drop to ground
        </i>
    </ul>
    <ul id="toolbar_L">
        <li title="High Quality"><button onclick="hqRender.togglePipeline(); ui.buttonToggleHighQuality(this);"><i class="material-icons">camera</i></button></li>
        <li id="materials"><button title="Switch Material" onclick="material.switchMaterial()" class="txt">PBR</button></li>
        <li title="Layer Toolbox"><button onclick="ui.toggleMenuLayer()"><i class="material-icons">layers</i></button></li>
        <i class="tooltip"><h1>Left Menu (Rendering, Materials, Layers)</h1>
            <br><b>High Quality</b> toggle high-quality render mode
            <br><b>Switch Material</b> switch Cell, PBR and Standard materials
            <br><b>Layer Toolbox</b> open a menu with multiple options to work with layers, include [ Hide Picked Color ] tool
        </i>
    </ul>
    <ul id="toolbar_C">
        <li title="Set Storage" onclick="setStorage()">SET</li>
        <li title="Get Storage" onclick="getStorage()">GET</li>
        <li onclick="memory.loadStep(0)" class="mem" class="memory_select">0</li>
        <li onclick="memory.loadStep(1)" class="mem">1</li>
        <li onclick="memory.loadStep(2)" class="mem">2</li>
        <li onclick="memory.loadStep(3)" class="mem">3</li>
        <li onclick="memory.loadStep(4)" class="mem">4</li>
        <li onclick="memory.loadStep(5)" class="mem">5</li>
        <li onclick="memory.loadStep(6)" class="mem">6</li>
        <li onclick="memory.loadStep(7)" class="mem">7</li>
        <li onclick="memory.loadStep(8)" class="mem">8</li>
        <li onclick="memory.loadStep(9)" class="mem">9</li>
        <i class="tooltip"><h1>Top Menu (Memory, Storage, Symmetry Axis)</h1>
            <br><b>Memory Steps (0~9)</b> record 10 steps, click on each step to revert changes, memory cleared on loading a new model
            <br><b>Local Storage (SET-GET)</b> local storage in browser history
            <br><b>Symmetry Axis (X-Y-Z)</b> symmetry axis used in drawing, painting and symmetrize functions
        </i>
       <li title="Symmetry Axis" onclick="symmetry.switchAxis(this)" class="axis_select">S</li>
    </ul>
    <ul id="hover">
        <li title="Tool: Free Camera" class="camera" onclick="tool.toolSelector('camera')" onpointerdown="ui.dragElement(this)"><i class="material-icons">control_camera</i></li>
        <li title="Tool: Bucket" class="bucket" onclick="tool.toolSelector('bucket')"><i class="material-icons">format_color_fill</i></li>
        <li title="Tool: Transform" class="transform" onclick="tool.toolSelector('transform')"><i class="material-icons">border_outer</i></li>
        <li title="Tool: Paint" class="paint" onclick="tool.toolSelector('paint')"><i class="material-icons">brush</i></li>
        <li title="Tool: Add" class="add" onclick="tool.toolSelector('add')"><i class="material-icons">create</i></li>
        <li title="Tool: Remove" class="remove" onclick="tool.toolSelector('remove')"><i class="material-icons">clear</i></li>
        <li title="Tool: Eyedropper" class="eyedrop" onclick="tool.toolSelector('eyedrop')"><i class="material-icons">colorize</i></li>
        <i class="tooltip"><h1>Hover Menu (Modeling, Painting, Transform)</h1>
            <br><b>Tool: Camera</b> switch to camera mode to speed up navigation or activate the transform-gizmo for baked meshes
            <br><b>Tool: Draw</b> add new voxels
            <br><b>Tool: Erase</b> remove voxels
            <br><b>Tool: Transform</b> transform voxels
            <br><b>Tool: Paint</b> paint selected color
            <br><b>Tool: Bucket</b> find and replace all similar colors
            <br><b>Tool: Eyedropper</b> pick a voxel color, not a pixel color!
            <br>- Enable symmetric drawing and painting by activating a symmetry axis [X,Y,Z] from the top menu
        </i>
    </ul>
    <div>
        <ul id="axisview">
            <li title="Bounding Box" onclick="ui.toggleBoundingBox(); ui.buttonToggleAxisView(this)"><i class="material-icons">view_in_ar</i></li>
            <li title="Shadow Catcher" onclick="ui.toggleShadowCatcher(); ui.buttonToggleAxisView(this)"><i class="material-icons">wb_sunny</i></li>
            <li title="Scene Grid" onclick="ui.toggleGrid(); ui.buttonToggleAxisView(this)"><i class="material-icons">blur_circular</i></li>
            <li title="Auto Rotation" onclick="toggleCameraAutoRotation(); ui.buttonToggleAxisView(this)"><i class="material-icons">3d_rotation</i></li>
            <li title="Debug Mode" onclick="ui.toggleDebugMode(); ui.buttonToggleAxisView(this)"><i class="material-icons">bug_report</i></li>
        </ul>
        <div title="Minimal Interface" id="axisview_hitbox" onclick="ui.toggleMinimalInterface()"></div>
        <i class="tooltip"><h1>Axis View (Display and Views)</h1>
            <br><b>Debug Mode</b> toggle babylon.js debug layer
            <br><b>Minimal Interface (Zen Mode)</b> toggle minimal interface for better mobile experience
        </i>
    </div>
    <div id="colorpicker">
        <div title="Color Picker">
            <input type="color" id="inputcolor" value="#3876C0">
            <i class="tooltip"><h1>Color Pickers</h1>
                <br><b>HTML Picker</b> accurate color picker for desktop
                <br><b>Advanced Picker</b> color wheel for desktop and mobile
                <br>- The selected color is universal and applied to everything you create, edit or import
            </i>
        </div>
    </div>
    <div title="Help" id="helpbtn" onclick="ui.toggleTooltips()"><i class="material-icons">help</i></div>
    <!-- dynamic -->
    <div id="layers">
        <ul id="layer" title="Layer (color palette)"></ul>
        <i class="tooltip"><h1>Color Layers</h1>
            <br>Every color is a layer, each layer consist of many voxels of similar color,
            it works with all the available tools, plus files and storage.
            <br>- Use <b>Double Click</b> to toggle layer visibility
        </i>
    </div>
    <div id="info"> <span>0</span> FPS | <span>0</span> Voxels | <span>0</span> Bakes</div>
    <!-- extras -->
    <div id="help"><div class="tip" onclick="ui.toggleTooltips()">
        <h1>Help and Instructions</h1>
        <p>Click or hover buttons to view a short instruction</p>
    </div></div>
    <div id="about" onclick="this.style.display='none'">
        <i class="material-icons">token</i>
        <h1>VOXEL BUILDER</h1>
        <b>VOXEL-BASED 3D MODELING</b>
        <span>Made with</span>
        <br><a href="https://www.babylonjs.com/community/"><img style="margin-top: 10px; margin-bottom: -15px; filter: brightness(1.4) contrast(1);" src="data:image/png;base64,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"></a>
        <br><br>[ 3.7.7 BETA 2022 ]
        <br><a href="https://github.com/nimadez/">GITHUB REPOSITORY</a>
        <br><a href="https://twitter.com/nimadez">©2019 @nimadez</a>
    </div>
    <div id="status">[ <b>3.7.7 BETA</b> ]</div>
    <div id="notifier"></div>
    <!-- hidden -->
    <input style="display: none" type="file" id="openfile_vox" accept=".vox" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_obj" accept=".obj" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_img" accept=".jpg,.png" onclick="this.value = null">
</body>
<script>
    // -------------------------------------------------------
    // Initialize

    const MAXAMOUNT = 64000;
    let currentColor = '#3876C0';

    const canvas = document.querySelectorAll('canvas')[0];
    const engine = new BABYLON.Engine(canvas, true, {});
    engine.disablePerformanceMonitorInBackground = true;
    engine.disableWebGL2Support = false;
    engine.preserveDrawingBuffer = false;
    engine.enableOfflineSupport = false;
    engine.doNotHandleContextLost = true;
    engine.loadingUIBackgroundColor = "#000000e1";

    const scene = createScene(engine);
    const sceneAxisView = createAxisViewScene(engine);
    //scene.debugLayer.show();

    const easingFunction = new BABYLON.CubicEase();
    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

    const material = new Material(scene);
    const builder = new Builder(scene);
    const layer = new Layer();
    const helper = new Helper(scene, sceneAxisView);
    const tool = new Tool(scene);
    const memory = new Memory();
    const symmetry = new Symmetry();
    const bakery = new Bakery(scene);
    const voxelizer = new Voxelizer();
    const hqRender = new HQRender(scene);
    const ui = new UserInterface(scene);
    const uix = new UserInterfaceAdvanced(scene);

    engine.runRenderLoop(() => {
        scene.render();
        sceneAxisView.render();
        sceneAxisView.activeCamera.alpha = scene.activeCamera.alpha;
        sceneAxisView.activeCamera.beta = scene.activeCamera.beta;
        ui.domFps.innerHTML = ~~engine.getFps();
    });

    setTimeout(()=>{document.getElementById('status').style.opacity=0},3500);
    

    // -------------------------------------------------------
    // Scene


    function createScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = false;
        scene.blockMaterialDirtyMechanism = true;

        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.setPosition(new BABYLON.Vector3(1,1,1)); // initial
        camera.setTarget(BABYLON.Vector3.Zero());
        setCamera(camera);

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8);
        ambient.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
        ambient.groundColor = new BABYLON.Color3(0.6, 0.6, 0.6);
        ambient.intensity = 0.3;

        const light = new BABYLON.DirectionalLight("direct", new BABYLON.Vector3(0, -1, 0), scene);
        setLightPositionByAngle(light, 120, 50, 100);
        light.autoUpdateExtends = true; // to REFRESHRATE_RENDER_ONCE
        light.diffuse = BABYLON.Color3.FromHexString('#ffffbb');
        light.intensity = 1;

        const light2 = new BABYLON.DirectionalLight("direct_noshadow", new BABYLON.Vector3(0, -1, 0), scene);
        setLightPositionByAngle(light2, 310, 50, 100);
        light2.diffuse = BABYLON.Color3.FromHexString('#ffffbb');
        light2.intensity = 1;

        let shadowRes = 512;
        if (isMobileDevice()) shadowRes /= 2;
        const shadowGen = new BABYLON.ShadowGenerator(shadowRes, light); // shadows updated manually on SPS.mesh changes,
        shadowGen.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE; // to save performance
        shadowGen.filteringQuality = BABYLON.ShadowGenerator.QUALITY_LOW;
        shadowGen.useExponentialShadowMap = true; // default true
        shadowGen.usePercentageCloserFiltering = true; // webgl2 only, fallback -> usePoissonSampling 
        shadowGen.forceBackFacesOnly = false;
        shadowGen.setDarkness(0.6);

        const shadowcatcher = BABYLON.MeshBuilder.CreateGround("shadowcatcher", {width: 100, height: 100}, scene);
        shadowcatcher.material = new BABYLON.ShadowOnlyMaterial('shadowcatcher', scene);
        shadowcatcher.material.shadowColor = BABYLON.Color3.FromHexString('#161a20');
        shadowcatcher.material.activeLight = light;
        shadowcatcher.material.backFaceCulling = true;
        shadowcatcher.material.alpha = 0.3;
        shadowcatcher.position.y = -0.5;
        shadowcatcher.receiveShadows = true;
        shadowcatcher.isPickable = false;
        shadowcatcher.doNotSyncBoundingInfo = true;
        shadowcatcher.convertToUnIndexedMesh();
        shadowcatcher.freezeWorldMatrix();
        shadowcatcher.freezeNormals();

        return scene;
    }

    function createAxisViewScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = true;
        scene.blockMaterialDirtyMechanism = true;

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, -1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(1, 1, 1);
        ambient.groundColor = new BABYLON.Color3(1, 1, 1);
        ambient.intensity = 1;

        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        camera.viewport = updateViewport(70, 70, 0, 0);
        camera.radius = 3;

        const cube = BABYLON.MeshBuilder.CreateBox("viewcube", {}, scene);
        cube.material = new BABYLON.NormalMaterial("viewcube", scene);
        cube.material.backFaceCulling = true;
        cube.material.alpha = 0.99;
        cube.material.freeze();
        cube.doNotSyncBoundingInfo = true;
        cube.enableEdgesRendering();
        cube.edgesWidth = 2;
        cube.edgesColor = BABYLON.Color4.FromHexString('#00000090');
        cube.convertToUnIndexedMesh(); // after edgesRendering
        cube.freezeWorldMatrix();
        cube.freezeNormals();

        const axes = new BABYLON.AxesViewer(scene, 0.6);
        axes.xAxis.parent = cube;
        axes.yAxis.parent = cube;
        axes.zAxis.parent = cube;

        return scene;
    }


    // -------------------------------------------------------
    // Material


    function Material(scene) {
        this.dom = document.getElementById('materials');
        this.mode = 'CEL'; // PBR, STD, CEL
        this.mat_default = null;
        this.mat_ghost = null;
        this.mat_workplane = null;
        this.mat_grid = null;
        this.mat_baked = null;
        this.voxelTexture = null; // voxel grid

        this.init = function() {
            this.createWorkplaneMaterial();
            this.createGridMaterial();
            this.createGhostMaterial();
            this.update();
            this.mat_baked = this.createBakedMaterial();
        }

        this.update = function() {
            if (this.mat_default) {
                this.mat_default.getActiveTextures()[0].dispose();
                this.mat_default.dispose();
                this.mat_default = null;
                this.voxelTexture = null;
            }
            if (this.mode == 'PBR') this.createPBRMaterial();
            if (this.mode == 'STD') this.createStandardMaterial();
            if (this.mode == 'CEL') this.createCellMaterial();

            this.dom.children[0].innerHTML = this.mode;
        }

        this.createCellMaterial = function() {
            const tex = this.createVoxelTexture('#000000');
            const mat = new BABYLON.StandardMaterial("cel", scene);
            tex.getAlphaFromRGB = false;
            mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            mat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            mat.emissiveTexture = tex;
            mat.opacityTexture = tex;
            mat.opacityFresnelParameters = new BABYLON.FresnelParameters();
            mat.opacityFresnelParameters.leftColor = new BABYLON.Color3(0.6, 0.6, 0.6);
            mat.opacityFresnelParameters.rightColor = new BABYLON.Color3(0.6, 0.6, 0.6);
            mat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
            mat.emissiveFresnelParameters.leftColor = new BABYLON.Color3(1, 1, 1);
            mat.emissiveFresnelParameters.rightColor = new BABYLON.Color3(1, 1, 1);
            mat.useEmissiveAsIllumination = false;
            mat.linkEmissiveWithDiffuse = true;
            mat.backFaceCulling = true;
            mat.transparencyMode = 0;
            mat.alpha = 0.3;
            mat.cameraContrast = 1;
            mat.cameraExposure = 1;
            this.mat_default = mat;
            this.voxelTexture = tex;
        }

        this.createPBRMaterial = function() {
            const tex = this.createVoxelTexture('#FFFFFF');
            const mat = new BABYLON.PBRMaterial("pbr", scene);
            tex.gammaSpace = false;
            mat.albedoColor = new BABYLON.Color3(1, 1, 1);
            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            mat.emissiveTexture = tex;
            mat.emissiveIntensity = 0.04;
            mat.specularIntensity = 1;
            mat.metallic = 0.1;
            mat.roughness = 1;
            mat.directIntensity = 1;
            mat.environmentIntensity = 1;
            mat.cameraContrast = 2;
            mat.cameraExposure = 1;
            mat.backFaceCulling = true;
            this.mat_default = mat;
            this.voxelTexture = tex;
        }

        this.createStandardMaterial = function() {
            const tex = this.createVoxelTexture('#111111');
            const mat = new BABYLON.StandardMaterial("std", scene);
            mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            mat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            mat.emissiveTexture = tex;
            mat.useEmissiveAsIllumination = true;
            mat.linkEmissiveWithDiffuse = false;
            mat.backFaceCulling = true;
            mat.cameraContrast = 1;
            mat.cameraExposure = 1;
            this.mat_default = mat;
            this.voxelTexture = tex;
        }

        this.createWorkplaneMaterial = function() {
            const tex = this.createWorkplaneTexture();
            const mat = new BABYLON.StandardMaterial("workplane", scene);
            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            mat.diffuseTexture = tex;
            mat.opacityTexture = tex;
            mat.backFaceCulling = true;
            mat.disableLighting = true;
            mat.freeze();
            this.mat_workplane = mat;
        }

        this.createGridMaterial = function() {
            const mat = new BABYLON.GridMaterial("grid", scene);
            mat.backFaceCulling = false;
            mat.gridRatio = 0.042;         // override by helper.setGrid() on scaling
            mat.majorUnitFrequency = 1000; // hide the unit, almost
            mat.minorUnitVisibility = 0.3;
            mat.mainColor = new BABYLON.Color3(1,1,1);
            mat.lineColor = new BABYLON.Color3(1,1,1);
            mat.opacity = 0.05;
            mat.freeze();
            this.mat_grid = mat;
        }

        this.createGhostMaterial = function() {
            const tex = this.createVoxelTexture('#FFFFFF');
            const mat = new BABYLON.StandardMaterial("ghost", scene);
            tex.getAlphaFromRGB = false;
            mat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            mat.emissiveTexture = tex;
            mat.backFaceCulling = true;
            mat.disableLighting = true;
            mat.freeze();
            this.mat_ghost = mat;
        }

        this.createBakedMaterial = function() {
            const mat = new BABYLON.StandardMaterial("baked", scene);
            mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            mat.backFaceCulling = true;
            mat.freeze();
            return mat;
        }

        this.createVoxelTexture = function(hex) {
            const tex = new BABYLON.DynamicTexture('voxel', 128, scene, BABYLON.Texture.LINEAR_LINEAR);
            const ctx = tex.getContext();
            ctx.lineWidth = 2; // grid
            ctx.strokeStyle = hex + 'AA';
            ctx.beginPath();
            ctx.moveTo(0, 64);
            ctx.lineTo(128, 64);
            ctx.moveTo(64, 0);
            ctx.lineTo(64, 128);
            ctx.stroke();
            ctx.lineWidth = 4; // outline
            ctx.strokeStyle = hex;
            ctx.strokeRect(0, 0, 128, 128);
            tex.update();
            tex.hasAlpha = true;
            return tex;
        }

        this.createWorkplaneTexture = function() {
            const tex = new BABYLON.DynamicTexture('workplane', 1024, scene, BABYLON.Texture.LINEAR_LINEAR);
            const ctx = tex.getContext();
            const size = 1024;
            const cen = size / 2;
            ctx.strokeStyle = '#ffffff15';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cen, cen, cen-10, 0, Math.PI*2);
            ctx.stroke();
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cen, cen, cen-20, 0, Math.PI*2);
            ctx.stroke();
            ctx.fillStyle = '#ffffff04';
            ctx.strokeStyle = '#ffffff25';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cen, cen, cen-30, 0, Math.PI*2);
            ctx.stroke();
            ctx.fill();
            ctx.fillStyle = '#ff373790'; // X
            ctx.fillRect(size-33, cen-2, 5,5);
            ctx.fillRect(30, cen-2, 5,5);
            ctx.fillStyle = '#4d9aff90'; // Z
            ctx.fillRect(cen-2, size-33, 5,5);
            ctx.fillRect(cen-2, 30, 5,5);
            tex.update();
            tex.hasAlpha = true;
            return tex;
        }

        this.switchMaterial = function() {
            if (this.mode == 'CEL') {
                this.dom.firstChild.innerHTML = 'PBR';
                this.mode = 'PBR';
            } else if (this.mode == 'PBR') {
                this.dom.firstChild.innerHTML = 'STD';
                this.mode = 'STD';
            } else if (this.mode == 'STD') {
                this.dom.firstChild.innerHTML = 'CEL';
                this.mode = 'CEL';
            }
            this.update();
            builder.createSPS();
        }

        this.toggleGridVisibility = function(visible) {
            if (visible) {
                this.voxelTexture.level = 1;
            } else {
                this.voxelTexture.level = 0;
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // Builder (SPS voxels)


    function Builder(scene) {
        this.voxels = []; // { position: vec3, color: hex/uppercase/no-opacity, visible: bool }
        this.voxel = null;
        this.SPS = null;

        this.init = function() {
            this.voxel = BABYLON.MeshBuilder.CreateBox("voxel", {}, scene);
            this.voxel.isVisible = false;
        }

        this.add = function(pos, hex, visible) {
            if (this.findIndexByPosition(pos) == -1) // no duplicates allowed
                this.voxels.push({ position: pos, color: hex, visible: visible });
        }

        this.remove = function(index) {
            if (builder.voxels.length < 2) return; // 1 voxel minimum, useless but keep it
            index = this.voxels.indexOf(this.voxels[index]);
            if (index > -1)
                this.voxels.splice(index, 1);
        }

        this.removeByPosition = function(pos) {
            this.remove(this.findIndexByPosition(pos));
        }

        this.removeByColor = function(hex) {
            let color = null;
            for (let i = 0; i < this.SPS.particles.length; i++) {
                color = rgbFloatToHex(this.SPS.particles[i].color.r, this.SPS.particles[i].color.g, this.SPS.particles[i].color.b);
                if (color === hex)
                    this.removeByPosition(this.SPS.particles[i].position);
            }
        }

        this.findIndexByPosition = function(pos) {
            return this.voxels.findIndex(i => i.position.equals(pos));
        }

        this.findIndexByColor = function(hex) {
            return this.voxels.findIndex(i => i.color === hex);
        }

        this.createSPS = function(voxels = this.voxels) {
            if (this.SPS) {
                this.SPS.dispose();
                this.SPS = null;
            }
            this.SPS = new BABYLON.SolidParticleSystem('SPS', scene, { isPickable: true, updatable: true, expandable: false });
            
            this.SPS.addShape(this.voxel, voxels.length, { positionFunction: (particle, i, s) => {
                particle.position.copyFrom(voxels[i].position);
                particle.color = BABYLON.Color4.FromHexString(voxels[i].color);
            }});

            this.SPS.initParticles = () => {
                for (let i = 0; i < this.SPS.nbParticles; i++) {  // respect hidden voxels
                    this.SPS.particles[i].isVisible = voxels[i].visible; // to enable new feature: layers
                }
            }

            const mesh = this.SPS.buildMesh();
            mesh.material = material.mat_default;
            mesh.receiveShadows = true;
            mesh.hasVertexAlpha = false;
            scene.lights[1].getShadowGenerator().addShadowCaster(mesh);

            this.SPS.initParticles();
            this.SPS.setParticles();         // update SPS mesh and draw it
            this.SPS.refreshVisibleSize();   // update BBox for picking and shadows
            this.SPS.computeBoundingBox = true;
            this.SPS.computeParticleColor = true;
            this.SPS.computeParticleRotation = false;
            this.SPS.computeParticleTexture = false;
            this.SPS.computeParticleVertex = false;

            updateShadowMap();
            helper.setGrid(mesh);
            ui.updateStatus();
        }

        this.setVoxelPosition = function(index, pos) {
            this.voxels[index].position = pos;
            this.SPS.particles[index].position = pos;
        }

        this.setVoxelColor = function(index, hex) {
            this.voxels[index].color = hex;
            this.SPS.particles[index].color = BABYLON.Color4.FromHexString(hex);
            this.SPS.setParticles(index, index, true);
        }

        this.setVoxelVisible = function(index, visible) {
            this.voxels[index].visible = visible;
            this.SPS.particles[index].isVisible = visible;
        }

        this.getData = function() {
            return JSON.stringify(this.voxels);
        }

        this.setData = function(json) { // raw i/o, used in Memory Steps and Storage
            let data = JSON.parse(json);
            let newData = [];
            for (let i = 0; i < data.length; i++) {
                newData.push({
                    position: new BABYLON.Vector3(data[i].position._x, data[i].position._y, data[i].position._z),
                    color: data[i].color,
                    visible: parseBool(data[i].visible)
                });
            }
            this.voxels = newData;
            this.createSPS();
            layer.create();
            data = null;
            newData = null;
        }

        this.loadData = function(data) {    // used in Project functions, reset and load everything,
            this.voxels = [];               // except memory steps (do after create() because 'memory.loadStep()' conflict)
            for (let i = 0; i < data.length; i++) // except symmetry axis (do after create() because 'memory steps' conflict)
                this.add(data[i].position, data[i].color, data[i].visible); // except frameCamera(), we don't want it too often
            this.createSPS();
            layer.create();
            // reset toggles
            ui.clearAllToggles();
            ui.clearAllButtons();
            data = null;
        }

        this.init();
    }


    // -------------------------------------------------------
    // Layer (color palette)


    function Layer() {
        this.dom = document.getElementById('layer');
        this.uniqueColors = [];
        this.layers = []; // store voxels, grouped by uniqueColors
        this.selected = [];

        this.create = function() {   // generate color palette
            this.dom.innerHTML = ""; // from current voxel colors
            this.uniqueColors = [];
            this.layers = [];
            this.selected = [];
            for (let i = 0; i < builder.voxels.length; i++) {
                if (this.uniqueColors.indexOf(builder.voxels[i].color) == -1) {
                    this.addLayer(builder.voxels[i].color);
                    this.uniqueColors.push(builder.voxels[i].color);
                    this.layers[this.uniqueColors.length] = [];
                }
                this.layers[this.uniqueColors.length].push(builder.voxels[i]);
            }
        }

        this.addLayer = function(hex) { // dynamically create color(li) inside palette(ul)
            const li = document.createElement('li');
            li.style.backgroundColor = hex;
            li.title = hex;

            if (this.isLayerVisible(hex)) { // respect the stored visibility state
                li.style.boxShadow = 'none';
            } else {
                li.style.boxShadow = 'inset 0 0 4px black';
            }

            li.addEventListener("click", function(ev) {
                currentColor = hex;
                uix.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
                if (layer.selected.indexOf(li) > -1) {
                    layer.popSelected(li);
                } else {
                    layer.pushSelected(li);
                }
            }, false);

            li.addEventListener("dblclick", function(ev) {
                if (layer.isLayerVisible(hex)) {
                    layer.setLayerVisible(hex, false);
                    li.style.boxShadow = 'inset 0 0 4px black';
                } else {
                    layer.setLayerVisible(hex, true);
                    li.style.boxShadow = 'none';
                }
            }, false);

            this.dom.appendChild(li);
        }

        this.pushSelected = function(li) {
            li.style.borderColor = 'orange';
            this.selected.push(li);
        }

        this.popSelected = function(li) {
            li.style.borderColor = '#333b47';
            const index = this.selected.indexOf(li);
            if (index > -1)
                this.selected.splice(index, 1);
        }

        this.hideSelected = function() {
            if (this.selected.length > 0) {
                for (let i = 0; i < this.selected.length; i++) {
                    this.setLayerVisible(this.selected[i].title, false);
                    this.selected[i].style.boxShadow = 'inset 0 0 4px black';
                }
            } else {
                ui.notification('select color layer(s)');
            }
        }

        this.showSelected = function() {
            if (this.selected.length > 0) {
                for (let i = 0; i < this.selected.length; i++) {
                    this.setLayerVisible(this.selected[i].title, true);
                    this.selected[i].style.boxShadow = 'none';
                }
            } else {
                ui.notification('select color layer(s)');
            }
        }

        this.deleteSelected = function() {
            if (this.selected.length > 0) {
                for (let i = 0; i < this.selected.length; i++) {
                    builder.removeByColor(this.selected[i].title);
                    this.dom.removeChild(this.selected[i]);
                }
                builder.createSPS();
                memory.record();
                this.selected = [];
            } else {
                ui.notification('select color layer(s)');
            }
        }

        this.deleteHidden = function() {
            const last = builder.SPS.particles.length;
            for (let i = 0; i < builder.SPS.particles.length; i++) {
                if (!builder.SPS.particles[i].isVisible) { // loop over SPS.particles to
                    builder.removeByPosition(builder.SPS.particles[i].position); // prevent index changes
                }
            }
            builder.createSPS();
            this.create();
            if (builder.SPS.particles.length !== last)
                memory.record(); // record on changes
        }

        this.clearSelection = function() {
            if (this.selected.length > 0) {
                for (let i = 0; i < this.selected.length; i++)
                    this.selected[i].style.borderColor = '#333b47';
                this.selected = [];
            } else {
                ui.notification('select color layer(s)');
            }
        }

        this.setLayerVisible = function(hex, isVisible) {
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color === hex)
                    builder.setVoxelVisible(i, isVisible);
            }
            builder.createSPS();
        }

        this.invertVisibility = function() {
            for (let i = 0; i < builder.voxels.length; i++) {
                builder.setVoxelVisible(i, !builder.voxels[i].visible);
            }
            builder.SPS.setParticles();
            updateShadowMap();
            this.create(); // update layer state
        }

        this.setAllLayersVisible = function() {
            for (let i = 0; i < builder.voxels.length; i++)
                builder.setVoxelVisible(i, true);
            builder.SPS.setParticles();
            updateShadowMap();
            this.create(); // update layer state
            helper.setGrid(builder.SPS.mesh);
        }

        this.isLayerVisible = function(hex) {
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color === hex)
                    return builder.voxels[i].visible;
            }
            return false;
        }
    }
    

    // -------------------------------------------------------
    // Helper (overlays)


    function Helper(scene, sceneAxisView) {
        this.workPlane = BABYLON.MeshBuilder.CreateDisc("workplane", { radius: 0.5, tessellation: 16, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.gridPlane = BABYLON.MeshBuilder.CreateDisc("gridplane", { radius: 0.475, tessellation: 16, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.axisPlane = BABYLON.MeshBuilder.CreatePlane("axisplane", { width: 1.3, height: 1.3, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, sceneAxisView);
        this.overlayPlane = BABYLON.MeshBuilder.CreatePlane("overlayplane", { sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
        this.overlayCube = BABYLON.MeshBuilder.CreateBox("overlaycube", { updatable: false }, scene);
        this.ghostVoxel = BABYLON.MeshBuilder.CreateBox("ghostvoxel", { updatable: false }, scene);
        this.ghostVoxels = [];
        this.ghostVoxelOnce = null;

        this.init = function() {
            this.workPlane.material = material.mat_workplane;
            this.workPlane.isVisible = true;
            this.workPlane.isPickable = false;
            this.workPlane.position.y -= 0.5;
            this.workPlane.rotation.x = Math.PI/2;
            this.workPlane.convertToUnIndexedMesh();
            this.workPlane.freezeNormals();
            this.gridPlane.material = material.mat_grid;
            this.gridPlane.isVisible = true;
            this.gridPlane.isPickable = false;
            this.gridPlane.position.y = -0.5;
            this.gridPlane.rotation.x = Math.PI/2;
            this.gridPlane.convertToUnIndexedMesh();
            this.gridPlane.freezeNormals();
            this.axisPlane.isVisible = false; // indicate symmetry-axis plane in AxisView scene
            this.axisPlane.isPickable = false;
            this.axisPlane.visibility = 0.9;
            this.axisPlane.renderOverlay = true;
            this.axisPlane.overlayAlpha = 0.5;
            this.axisPlane.overlayColor = BABYLON.Color3.FromHexString('#ff00ff');
            this.axisPlane.edgesWidth = 5;
            this.axisPlane.edgesColor = BABYLON.Color4.FromHexString('#ff00ff');
            this.axisPlane.enableEdgesRendering();
            this.axisPlane.convertToUnIndexedMesh();
            this.axisPlane.freezeNormals();
            this.overlayPlane.isVisible = false;
            this.overlayPlane.isPickable = false;
            this.overlayPlane.visibility = 0.1;
            this.overlayPlane.renderOverlay = true;
            this.overlayPlane.overlayAlpha = 0.5;
            this.overlayPlane.edgesWidth = 4;
            this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString('#ffa500ff');
            this.overlayPlane.enableEdgesRendering();
            this.overlayPlane.convertToUnIndexedMesh();
            this.overlayPlane.freezeNormals();
            this.overlayCube.isVisible = false;
            this.overlayCube.isPickable = false;
            this.overlayCube.visibility = 0.1;
            this.overlayCube.renderOverlay = true;
            this.overlayCube.overlayAlpha = 0.5;
            this.overlayCube.edgesWidth = 2;
            this.overlayCube.enableEdgesRendering();
            this.overlayCube.convertToUnIndexedMesh();
            this.overlayCube.freezeNormals();
            this.ghostVoxel.scaling.scaleInPlace(1.01); // important in v5.0.0+
            this.ghostVoxel.material = material.mat_ghost;
            this.ghostVoxel.isVisible = false;
            this.ghostVoxel.visibility = 1;
            this.ghostVoxel.renderOverlay = true;
            this.ghostVoxel.overlayAlpha = 0.8;
            this.ghostVoxel.convertToUnIndexedMesh();
            this.ghostVoxel.freezeNormals();
        }

        this.setGrid = function(mesh) {
            const bounds = mesh.getBoundingInfo();
            const radius = bounds.boundingSphere.radius;
            const center = bounds.boundingSphere.center;
            animator(this.workPlane, 'position', this.workPlane.position, new BABYLON.Vector3(center.x, -0.5, center.z));
            animator(this.workPlane, 'scaling',  this.workPlane.scaling,  new BABYLON.Vector3(radius * 3, radius * 3, 1));
            animator(this.gridPlane, 'position', this.gridPlane.position, new BABYLON.Vector3(center.x, -0.5, center.z));
            animator(this.gridPlane, 'scaling',  this.gridPlane.scaling,  new BABYLON.Vector3(radius * 3, radius * 3, 1));
            this.gridPlane.material.gridRatio = 0.167 / radius;
            if (this.gridPlane.material.gridRatio < 0.01) // enlarge grid unit
                this.gridPlane.material.gridRatio *= 2;   // for larger meshes
        }

        this.setAxisPlane = function(axis, pos) { // BABYLON.Axis.X
            this.axisPlane.isVisible = true;
            this.axisPlane.position = pos;
            this.axisPlane.rotation = BABYLON.Vector3.Zero();
            if (axis.x == 1) this.axisPlane.rotation.y = Math.PI/2;
            if (axis.y == 1) this.axisPlane.rotation.x = Math.PI/2;
            if (axis.z == 1) this.axisPlane.rotation.z = Math.PI/2;
        }

        this.clearAxisPlane = function() {
            this.axisPlane.isVisible = false;
        }

        this.setOverlayPlane = function(pos, normAxis, hex) {
            const axis = BABYLON.Vector3.Cross(BABYLON.Axis.Z, normAxis);
            const angle = Math.acos(BABYLON.Vector3.Dot(normAxis, BABYLON.Axis.Z));
            this.overlayPlane.isVisible = true;
            this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(hex);
            this.overlayPlane.position = pos;
            this.overlayPlane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis, angle);
        }

        this.setOverlayCube = function(pos, scale, hex) {
            this.overlayCube.isVisible = true;
            this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(hex);
            this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(hex + 'FF');
            this.overlayCube.position = pos;
            this.overlayCube.scaling = scale;
        }

        this.clearOverlays = function() {
            this.overlayCube.isVisible = false;
            this.overlayPlane.isVisible = false;
        }

        this.setGhostVoxelOnce = function(pos) {
            if (this.ghostVoxelOnce)
                this.ghostVoxelOnce.dispose();
            this.ghostVoxelOnce = this.ghostVoxel.clone();
            this.ghostVoxelOnce.isVisible = true;
            this.ghostVoxelOnce.visibility = 0.05;
            this.ghostVoxelOnce.overlayAlpha = 0.15;
            this.ghostVoxelOnce.overlayColor = BABYLON.Color3.FromHexString('#00FFFF');
            this.ghostVoxelOnce.position = pos;
        }

        this.clearGhostVoxelOnce = function() {
            if (this.ghostVoxelOnce)
                this.ghostVoxelOnce.dispose();
        }

        this.cloneGhostVoxel = function(pos, hex) {
            const clone = this.ghostVoxel.clone();
            clone.isVisible = true;
            clone.position = pos;
            clone.overlayColor = BABYLON.Color3.FromHexString(hex);
            clone.material.diffuseColor = BABYLON.Color3.FromHexString(hex);
            this.ghostVoxels.push(clone);
        }

        this.clearGhostVoxels = function() {
            if (this.ghostVoxels.length > 0) {
                for (let i = 0; i < this.ghostVoxels.length; i++)
                    this.ghostVoxels[i].dispose();
                this.ghostVoxels = [];
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // Tool


    function Tool(scene) {
        this.name = 'camera';
        this.selected = [];
        this.isMouseDown = false;
        this.lastCamPos = null;
        this.pick = null;

        this.init = function() {
            this.toolSelector(this.name); // startup tool
        }

        this.add = function(pos) {
            if (!builder.voxels[builder.findIndexByPosition(pos)]) {
                helper.cloneGhostVoxel(pos, currentColor);
            } else {
                helper.cloneGhostVoxel(pos, '#FF3333'); // indicate invisible voxel
            }
            this.selected.push(pos); // add voxels onToolUp to save performance
        }

        this.addSymmetry = function(pos, axis) {
            pos = symmetry.invertPos(pos, axis);
            this.add(pos);
        }

        this.remove = function(pos) {
            helper.cloneGhostVoxel(pos, "#FF3333");
            this.selected.push(pos); // removing voxels onToolUp to prevent infinite-depth picking
        }

        this.removeSymmetry = function(pos, axis) {
            this.remove(symmetry.invertPos(pos, axis));
        }

        this.transform = function(posBegin, posEnd, index) {
            for (let i = 0; i < this.selected.length; i++) { // prevent infinite-depth picking
                if (this.selected[i].equals(posBegin))
                    return;
            }
            if (builder.findIndexByPosition(posEnd) == -1) {  // no duplicates on merge,
                builder.setVoxelPosition(index, posEnd);      // when symmetry met certain conditions,
                builder.SPS.setParticles(index, index, true); // ex. transform cause a merge of two parallel voxels.
                this.selected.push(posEnd);
            }
        }

        this.transformSymmetry = function(posBegin, posEnd, index, axis) {
            index = symmetry.findIndexInvert(posBegin, axis);
            if (index == -1) return;
            posEnd = symmetry.invertPos(posEnd, axis);
            this.transform(posBegin, posEnd, index);
        }

        this.paint = function(index) {
            builder.setVoxelColor(index, currentColor);
        }

        this.paintSymmetry = function(index, axis) {
            index = symmetry.findIndexInvert(builder.voxels[index].position, axis);
            if (index == -1) return;
            this.paint(index);
        }

        this.eyedrop = function(hexcolor) {
            currentColor = hexcolor;
            uix.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
        }

        this.bucket = function(hexcolor) {
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color === hexcolor)
                    builder.setVoxelColor(i, currentColor);
            }
        }

        this.hideByPick = function(hex, index) {
            layer.setLayerVisible(hex, false);
        }

        this.onToolDown = function(pick) {
            if (pick && pick.faceId == -1) return;
            if (!this.pauseCameraControls()) return;
            const index = builder.SPS.pickedParticles[pick.faceId].idx;
            const particle = builder.SPS.particles[index];
            const norm = pick.getNormal(true);
            const pos = particle.position;
            switch (this.name) {
                case 'add':
                    this.add(pos.add(norm));
                    if (symmetry.axis !== '')
                        this.addSymmetry(pos.add(norm), symmetry.axis);
                    break;
                case 'remove':
                    this.remove(pos);
                    if (symmetry.axis !== '')
                        this.removeSymmetry(pos, symmetry.axis);
                    break;
                case 'transform':
                    this.transform(pos, pos.add(norm), index);
                    if (symmetry.axis !== '')
                        this.transformSymmetry(pos, pos.add(norm), index, symmetry.axis);
                    updateShadowMap(); // important
                    break;
                case 'paint':
                    this.paint(index);
                    if (symmetry.axis !== '')
                        this.paintSymmetry(index, symmetry.axis);
                    break;
                case 'eyedrop':
                    this.eyedrop(builder.voxels[index].color);
                    break;
                case 'bucket':
                    this.bucket(builder.voxels[index].color);
                    break;
                case 'hidebypick':
                    this.hideByPick(builder.voxels[index].color, index);
                    break;
            }
        }

        this.onToolMove = function(pick) {
            if (pick && pick.faceId == -1) return;
            const index = builder.SPS.pickedParticles[pick.faceId].idx;
            const particle = builder.SPS.particles[index];
            const norm = pick.getNormal(true);
            const pos = particle.position;
            switch (this.name) {
                case 'add':
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm, '#FFA500');
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.add(pos.add(norm));
                        if (symmetry.axis !== '')
                            this.addSymmetry(pos.add(norm), symmetry.axis);
                    }
                    break;
                case 'remove':
                    helper.setOverlayCube(pos, BABYLON.Vector3.One(), '#FF0000');
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.remove(pos);
                        if (symmetry.axis !== '')
                            this.removeSymmetry(pos, symmetry.axis);
                    }
                    break;
                case 'transform':
                    helper.setGhostVoxelOnce(pos.add(norm));
                    helper.setOverlayCube(pos.add(norm), norm.add(new BABYLON.Vector3(0.01, 0.01, 0.01)), '#FFA500');
                    helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm, '#00FFFF');
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.transform(pos, pos.add(norm), index);
                        if (symmetry.axis !== '')
                            this.transformSymmetry(pos, pos.add(norm), index, symmetry.axis);
                        updateShadowMap(); // important
                    }
                    break;
                case 'paint':
                    helper.setOverlayCube(pos, BABYLON.Vector3.One(), currentColor);
                    if (this.isMouseDown && this.pauseCameraControls()) {
                        this.paint(index);
                        if (symmetry.axis !== '')
                            this.paintSymmetry(index, symmetry.axis);
                    }
                    break;
                case 'eyedrop':
                    helper.setOverlayCube(pos, BABYLON.Vector3.One(), builder.voxels[index].color);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.eyedrop(builder.voxels[index].color);
                    break;
                case 'bucket':
                    helper.setOverlayCube(pos, BABYLON.Vector3.One(), currentColor);
                    if (this.isMouseDown && this.pauseCameraControls())
                        this.bucket(builder.voxels[index].color);
                    break;
                case 'hidebypick':
                    helper.setOverlayCube(pos, BABYLON.Vector3.One(), "#FFFF00");
                    break;
            }
        }

        this.onToolUp = function(pick) {
            if (pick && pick.faceId == -1) return;
            switch (this.name) {
                case 'add':
                    for (let i = 0; i < this.selected.length; i++)
                        builder.add(this.selected[i], currentColor, true);
                    builder.createSPS();
                    layer.create();
                    memory.record();
                    break;
                case 'remove':
                    for (let i = 0; i < this.selected.length; i++)
                        builder.removeByPosition(this.selected[i]);
                    builder.createSPS();
                    layer.create();
                    memory.record();
                    break;
                case 'transform':
                    builder.createSPS();
                    layer.create();
                    memory.record();
                    break;
                case 'paint':
                    layer.create();
                    memory.record();
                    break;
                case 'bucket':
                    builder.createSPS();
                    layer.create();
                    memory.record();
                    break;
                case 'hidebypick':
                    layer.create();
                    break;
            }
            this.selected = [];
        }

        this.toolSelector = function(toolName) {
            this.name = toolName;

            const elem = document.getElementsByClassName(this.name)[0];
            for (let i of document.querySelectorAll('li'))
                if (i.classList.contains("tool_selector"))
                    i.classList.remove("tool_selector");
            for (let i of document.querySelectorAll('button'))
                if (i.classList.contains("tool_selector"))
                    i.classList.remove("tool_selector");
            elem.classList.add("tool_selector");

            helper.clearGhostVoxelOnce();
            helper.clearOverlays();
        }

        this.handleToolDown = function(ev) {
            this.isMouseDown = true;
            this.lastCamPos = scene.activeCamera.position.clone();
            if (this.name !== 'camera') { // speed up navigation
                this.pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) {
                    return mesh === builder.SPS.mesh;
                });
                if (this.pick.hit) {
                    tool.onToolDown(this.pick);
                }
                uix.unbindGizmo();
                bakery.clearSelected();
            } else { // bind transform gizmo to meshes
                this.pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) {
                    return bakery.meshes.includes(mesh);
                });
                if (this.pick.hit) {
                    bakery.clearSelected();
                    uix.bindGizmo(bakery.meshes);
                } else {
                    uix.unbindGizmo();
                    bakery.clearSelected();
                }
            }
        }

        this.handleToolMove = function(ev) {
            if (this.name !== 'camera') {
                setTimeout(function() { // faster
                    this.pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) {
                        return mesh === builder.SPS.mesh;
                    });
                    if (this.pick.hit) {
                        tool.onToolMove(this.pick);
                    } else { // important: prevent last ghost/overlay after drawing
                        helper.clearGhostVoxelOnce();
                        helper.clearOverlays();
                    }
                }, 1000 / 30);
            }
        }

        this.handleToolUp = function(ev) {
            this.isMouseDown = false;
            if (this.name !== 'camera') {
                this.onToolUp(this.pick);

                helper.clearGhostVoxels();
                setTimeout(() => { // a little hack to prevent last ghost/overlay
                    helper.clearGhostVoxelOnce(); // in touch devices
                    helper.clearOverlays();
                }, 100);
            }
            scene.activeCamera.attachControl(canvas, true);
        }

        this.pauseCameraControls = function() { // prevent tool and camera-control conflict
            if (!this.lastCamPos.equals(scene.activeCamera.position))
                return false;
            scene.activeCamera.detachControl(canvas);
            return true;
        }

        this.init();
    }


    // -------------------------------------------------------
    // Memory


    function Memory() {
        this.mem = [];
        this.step = -1;
        this.dom = document.querySelectorAll('#toolbar_C li.mem');

        this.record = function() {
            this.step++;
            if (this.step > 9) this.step = 0;
            if (this.step < 0) this.step = 9;
            this.mem[this.step] = builder.getData();

            for (let i of this.dom)
                i.classList.remove("memory_select");
            this.dom[this.step].classList.add("memory_select");
        }

        this.load = function() {
            if (this.step > 9) this.step = 0;
            if (this.step < 0) this.step = 9;
            if (!this.mem[this.step]) return;
            builder.setData(this.mem[this.step]);

            for (let i of this.dom)
                i.classList.remove("memory_select");
            this.dom[this.step].classList.add("memory_select");
        }

        this.loadStep = function(step) {
            if (this.mem[step]) {
                builder.setData(this.mem[step]);
                this.step = step;

                for (let i of this.dom)
                    i.classList.remove("memory_select");
                this.dom[step].classList.add("memory_select");
            } else {
                ui.notification('empty memory');
            }
        }

        this.undo = function() {
            if (this.mem[this.step - 1]) {
                this.step--;
                this.load();
            }
        }

        this.redo = function() {
            if (this.mem[this.step + 1]) {
                this.step++;
                this.load();
            }
        }

        this.clear = function() {
            this.mem = [];
            this.step = -1;
            this.record(); // init memory block 0
        }
    }


    // -------------------------------------------------------
    // Symmetry


    function Symmetry() {
        this.axis = ''; // 'x'

        this.setAxis = function(axis) {
            this.axis = axis;
            helper.clearAxisPlane();
            if (axis == 'x') {
                helper.setAxisPlane(BABYLON.Axis.X, BABYLON.Vector3.Zero());
            } else if (axis == 'y') {
                helper.setAxisPlane(BABYLON.Axis.Y, BABYLON.Vector3.Zero());
            } else if (axis == 'z') {
                helper.setAxisPlane(BABYLON.Axis.Z, BABYLON.Vector3.Zero());
            }
        }

        this.switchAxis = function(elem) {
            if (this.axis == '') {
                elem.innerHTML = 'X';
                elem.style.color = '#ff6347';
                this.setAxis('x', elem);
            } else if (this.axis == 'x') {
                elem.innerHTML = 'Y';
                elem.style.color = '#34c239';
                this.setAxis('y', elem);
            } else if (this.axis == 'y') {
                elem.innerHTML = 'Z';
                elem.style.color = '#4d9aff';
                this.setAxis('z', elem);
            } else if (this.axis == 'z') {
                elem.innerHTML = 'S';
                elem.style.color = 'palevioletred';
                this.resetAxis();
            }
        }

        this.resetAxis = function() {
            this.axis = '';
            this.setAxis(this.axis);
            document.getElementsByClassName('axis_select')[0].innerHTML = 'S';
            document.getElementsByClassName('axis_select')[0].style.color = 'orange';
        }

        this.symmetrizeVoxelPositions = function(side) {
            if (this.axis == '') {
                ui.notification('select symmetry axis');
                return;
            }
            layer.setAllLayersVisible();
            if (side == 1) { // pos-to-neg
                this.deleteHalf(1);
                this.mirrorVoxels();
            } else { // neg-to-pos
                this.deleteHalf(-1);
                this.mirrorVoxels();
            }
            builder.createSPS();
            layer.create();
            memory.record();
        }

        this.mirrorVoxelPositions = function() {
            if (this.axis == '') {
                ui.notification('select symmetry axis');
                return;
            }
            layer.setAllLayersVisible();
            this.invertVoxels();
            builder.createSPS();
            layer.create();
            memory.record();
        }

        this.deleteHalf = function(side) { // preserve 0 borders, prevent duplicates at the middle
            let p = null; // reminder: 0.00000001 for vertex, voxel is 1.0, >=0.1 is more than enough!
            for (let i = 0; i < builder.SPS.particles.length; i++) {
                p = builder.SPS.particles[i].position;
                if (this.axis == 'x') {
                    if (side == -1 && this.center(p.x) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.x) >= 0.1)  builder.removeByPosition(p);
                }
                if (this.axis == 'y') {
                    if (side == -1 && this.center(p.y) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.y) >= 0.1)  builder.removeByPosition(p);
                }
                if (this.axis == 'z') {
                    if (side == -1 && this.center(p.z) <= -0.1) builder.removeByPosition(p);
                    if (side == 1  && this.center(p.z) >= 0.1)  builder.removeByPosition(p);
                }
            }
            p = null;
        }

        this.mirrorVoxels = function() {
            for (let i = 0; i < builder.voxels.length; i++)
                builder.add(this.invertPos(builder.voxels[i].position), builder.voxels[i].color, true);
        }

        this.invertVoxels = function() {
            for (let i = 0; i < builder.voxels.length; i++) {
                builder.voxels[i].position = this.invertPos(builder.voxels[i].position);
            }
        }

        this.invertPos = function(pos) { // invert positive to negative and reverse
            if (this.axis == 'x') pos = new BABYLON.Vector3(this.center2(pos.x), pos.y, pos.z);
            if (this.axis == 'y') pos = new BABYLON.Vector3(pos.x, this.center2(pos.y), pos.z);
            if (this.axis == 'z') pos = new BABYLON.Vector3(pos.x, pos.y, this.center2(pos.z));
            return pos;
        }

        this.center = function(p) { // calculate position from center
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return center.x - p;
            if (this.axis == 'y') return center.y - p;
            if (this.axis == 'z') return center.z - p;
        }

        this.center2 = function(p) { // calculate position from center*2
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return (center.x * 2) - p;
            if (this.axis == 'y') return (center.y * 2) - p;
            if (this.axis == 'z') return (center.z * 2) - p;
        }

        this.findIndexInvert = function(pos) {
            pos = this.invertPos(pos, this.axis);    // return index at mirrored position,
            return builder.findIndexByPosition(pos); // or '-1' if not exist
        }
    }


    // -------------------------------------------------------
    // Bakery (baked meshes)
    
    
    function Bakery(scene) {
        this.meshes = [];
        this.selected = null;
        
        this.bakeToMesh = function() {
            const baked = builder.SPS.mesh.clone('baked');
            baked.material = material.mat_baked;
            this.meshes.push(baked);

            this.clearSelected();
            this.selectMesh(baked);
            
            uix.bindGizmo(baked);
            uix.gizmo.attachToMesh(baked);

            builder.createSPS(); // important, clone geometry is shared

            tool.toolSelector('camera');
            ui.updateStatus();
        }

        this.cloneSelected = function() {
            if (this.selected) {
                this.meshes.push(this.selected.clone('baked_clone'));
                builder.createSPS(); // important, clone geometry is shared
                ui.updateStatus();
            } else {
                ui.notification('select a bake');
            }
        }

        this.deleteSelected = function() {
            if (this.selected) {
                this.meshes.splice(this.meshes.indexOf(this.selected), 1);
                this.selected.dispose();
                this.selected = null;
                uix.unbindGizmo();
                ui.updateStatus();
            } else {
                ui.notification('select a bake');
            }
        }

        this.selectMesh = function(mesh) {
            this.selected = mesh;
            this.selected.renderOutline = true;
            this.selected.outlineWidth = 0.025;
            this.selected.outlineColor = BABYLON.Color3.FromHexString('#ffa500');
        }

        this.clearSelected = function() {
            if (this.selected)
                this.selected = null;
            for (let i = 0; i < this.meshes.length; i++)
                this.meshes[i].renderOutline = false;
        }

        this.displayBakes = function(isVisible) {
            if (isVisible) {
                for (let i = 0; i < this.meshes.length; i++)
                    this.meshes[i].isVisible = true;
            } else {
                for (let i = 0; i < this.meshes.length; i++)
                    this.meshes[i].isVisible = false;
            }
            this.clearSelected();
            uix.unbindGizmo();
        }

        this.clearBakes = function() {
            if (this.meshes.length > 0) {
                if (!confirm("Delete All The Bakes?")) return;
                for (let i = 0; i < this.meshes.length; i++)
                    this.meshes[i].dispose();
                this.meshes = [];
                this.selected = null;
                uix.unbindGizmo();
                ui.updateStatus();
            }
        }
    }
    
    
    // -------------------------------------------------------
    // Voxelizer


    function Voxelizer() {

        this.voxelize = function(mesh) {
            const scale = parseInt(document.getElementById('input-voxelizer-scale').value);
            const density = parseInt(document.getElementById('input-voxelizer-density').value);
            
            // calculate random points per surface area,
            // voxel is 1x1x1, larger mesh size require more voxels,
            // and longer surface require more points to fill details.
            normalizeMesh(mesh, scale);
            let points = getRandomPointsOnMeshSurface(mesh, density);

            // builder.add() prevent duplicate, and
            // the old algorithm is not necessary,
            // no rays no clouds no gpu, just a floor()!
            // 10 times faster than previous versions.
            let data = [];
            for (let i = 0; i < points.length; i++) {
                data.push({ position: points[i].floor(), color: currentColor, visible: true });
            }
            builder.loadData(data);
            memory.clear();
            symmetry.resetAxis();
            frameCamera();

            points = null;
            data = null;
        }

        this.voxelize2D = function(imgData) {
            const ratio = parseFloat(document.getElementById('input-voxelizer-ratio').value);
            const zUp = parseBool(document.getElementById('input-voxelizer-zup').checked);
            const img = new Image();
            img.src = imgData;
            img.onload = () => {
                const c = document.createElement('canvas');
                const cx = c.getContext('2d');

                const dim = aspectRatioFit(img.width, img.height, 10*ratio, 10*ratio);
                c.width = dim.width;
                c.height = dim.height;

                cx.msImageSmoothingEnabled = false;
                cx.mozImageSmoothingEnabled = false;
                cx.webkitImageSmoothingEnabled = false;
                cx.imageSmoothingEnabled = false;
                cx.drawImage(img, 0, 0, c.width, c.height);

                let data = [];
                let imageData = cx.getImageData(0, 0, c.width, c.height).data;
                let x,y,r,g,b,a;
                for (let i = 0; i < imageData.length; i += 4) {
                    if (imageData[i + 3] > 0) {
                        r = imageData[i];
                        g = imageData[i + 1];
                        b = imageData[i + 2];
                        x = (i / 4) % c.width;
                        y = ~~(i / 4 / c.width);
                        if (zUp) {
                            data.push({ position: new BABYLON.Vector3(-x, dim.height-y-1, 0).floor(), color: rgbIntToHex(r, g, b), visible: true });
                        } else {
                            data.push({ position: new BABYLON.Vector3(-x, 0, y).floor(), color: rgbIntToHex(r, g, b), visible: true });
                        }
                    }
                }
                builder.loadData(data);
                memory.clear();
                symmetry.resetAxis();
                normalizeVoxelPositions(false);
                frameCamera();

                data = null;
                imgData = null;
                imageData = null;
                delete c;
                delete img;
            }
        }
    }


    // -------------------------------------------------------
    // HQRender (pipeline)


    function HQRender(scene) {
        this.isHQ = false;
        this.pipeline = null;
        this.ssao = null;

        this.togglePipeline = function() {
            if (this.pipeline) {
                this.removePipeline();
            } else {
                scene.clearColor = BABYLON.Color4.FromHexString('#586277');

                this.ssao = new BABYLON.SSAORenderingPipeline("ssao", scene, { ssaoRatio: 0.5, combineRatio: 1.0 }, [scene.activeCamera]);
                this.ssao.fallOff = 0.000001;
                this.ssao.area = 1;
                this.ssao.radius = 0.0001;
                this.ssao.totalStrength = 0.98;
                this.ssao.base = 0.6;

                this.pipeline = new BABYLON.DefaultRenderingPipeline("default", false, scene, [scene.activeCamera]); //false:hdr
                const curve = new BABYLON.ColorCurves();
                this.pipeline.fxaaEnabled = !isMobileDevice(); //pipeline.samples = 4;
                this.pipeline.sharpenEnabled = true;
                this.pipeline.sharpen.edgeAmount = 0.1;
                this.pipeline.grainEnabled = true;
                this.pipeline.grain.intensity = 2;
                this.pipeline.grain.animated = false;

                this.isHQ = true;
            }
        }

        this.removePipeline = function() {
            if (this.pipeline) {
                this.ssao.dispose();
                this.ssao = null;
                this.pipeline.dispose();
                this.pipeline = null;

                this.isHQ = false;
                scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
            }
        }
    }


    // -------------------------------------------------------
    // Projects


    function newProject() {
        let data = [];
        data.push({ position: new BABYLON.Vector3(0.5, 0, 0.5), color: currentColor, visible: true });
        data.push({ position: new BABYLON.Vector3(-0.5, 0, -0.5), color: currentColor, visible: true });
        data.push({ position: new BABYLON.Vector3(-0.5, 0, 0.5), color: currentColor, visible: true });
        data.push({ position: new BABYLON.Vector3(0.5, 0, -0.5), color: currentColor, visible: true });
        builder.loadData(data);
        memory.clear();
        symmetry.resetAxis();
        frameCamera(3);
        data = null;
    }

    function loadProject(voxdata) {
        let lines = voxdata.split('\n');
        let data = [];
        let chunk = [];
        let line = '';
        for (let i = 0; i < lines.length; i++) {
            if (lines[i]) { // ignore empty lines
                line = lines[i].replace(/\s+/g, ''); // strip whitespaces
                chunk = line.split(',');
                data.push({ 
                    position: new BABYLON.Vector3(parseFloat(chunk[0]), parseFloat(chunk[1]), parseFloat(chunk[2])),
                    color: chunk[3],
                    visible: parseBool(chunk[4])
                });
            }
        }
        builder.loadData(data);
        memory.clear();
        symmetry.resetAxis();
        frameCamera();
        data = null;
        chunk = null;
        lines = null;
    }

    function saveProject() {
        let data = '';
        for (let i = 0; i < builder.voxels.length; i++)
            data += builder.voxels[i].position.x + ',' + builder.voxels[i].position.y + ',' + builder.voxels[i].position.z + ',' + builder.voxels[i].color + ',' + builder.voxels[i].visible + '\n';
        downloadText(data, 'vbproject.vox');
        data = null;
    }

    function importMesh(url, ext) {
        engine.displayLoadingUI();
        let mesh = null;
        BABYLON.SceneLoader.LoadAssetContainerAsync(url, "", scene, null, ext).then(function(container) {
            mesh = BABYLON.Mesh.MergeMeshes(container.meshes, true, true);
            voxelizer.voxelize(mesh);
            mesh.dispose();
            mesh = null;
            engine.hideLoadingUI();
        }).catch(function(reason) {
            if (mesh) mesh.dispose();
            mesh = null;
            engine.hideLoadingUI();
            ui.notification("unable to import model");
            console.error(reason.message);
        });
    }

    function exportGLB(isBaked) {
        if (isBaked && bakery.meshes.length == 0) {
            ui.notification('no baked mesh to export');
            return;
        }
        engine.displayLoadingUI();
        let mesh = builder.SPS.mesh.clone();
        mesh.position.y += 0.5;
        mesh.material = material.mat_baked;
        const options = {
            shouldExportNode: function(node) {
                if (isBaked) {
                    return bakery.meshes.includes(node);
                } else {
                    return node === mesh;
                }
            }
        }
        BABYLON.GLTF2Export.GLBAsync(scene, "vbexport", options).then((glb) => {
            glb.downloadFiles();
            mesh.dispose();
            mesh = null;
            engine.hideLoadingUI();
        });
    }

    function pasteBase64Image() {
        navigator.clipboard.readText()
            .then(text => {
                if (text.startsWith('data:image/')) {
                    voxelizer.voxelize2D(text);
                } else {
                    ui.notification('invalid base64 image');
                }
            })
            .catch(err => {
                ui.notification('failed to read clipboard data');
            });
    }


    // -------------------------------------------------------
    // Storage


    function setStorage() {
        if (builder.voxels.length >= MAXAMOUNT) {
            ui.notification("large data, unable to store model");
            return;
        }
        localStorage.setItem("voxelstorage", builder.getData());
    }
    
    function getStorage() {
        let data = localStorage.getItem("voxelstorage");
        if (!data) {
            ui.notification("empty storage");
            return;
        }
        builder.setData(data);
        data = null;
    }


    // -------------------------------------------------------
    // Generator


    function createGrid() {
        const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
        const Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
        const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
        let data = [];
        for (let x = -X; x <= X; x++) {
            for (let y = 0; y <= Y * 2; y++) {
                for (let z = -Z; z <= Z; z++) {
                    data.push({ position: new BABYLON.Vector3(x, y, z), color: currentColor, visible: true });
                }
            }
        }
        builder.loadData(data);
        memory.clear();
        symmetry.resetAxis();
        frameCamera();
        data = null;
    }

    function createTerrain() {
        const X = parseInt(document.getElementById('input-terrain-x').value) / 2;
        const Y = parseInt(document.getElementById('input-terrain-y').value);
        const Z = parseInt(document.getElementById('input-terrain-z').value) / 2;
        const perlin = new ClassicalNoise();
        const inc = 0.05;
        let data = [];
        let xoff = 0;
        let zoff = 0;
        let v = 0;
        let pos = null;
        for (let x = -X; x < X; x++) {
            for (let z = -Z; z < Z; z++) {
                xoff = inc * x;
                zoff = inc * z;
                v = Math.round(perlin.noise(xoff, 0, zoff) * Y);
                pos = new BABYLON.Vector3(x, v, z);
                data.push({ position: pos, color: currentColor, visible: true });
            }
        }
        builder.loadData(data);
        symmetry.resetAxis();
        normalizeVoxelPositions(false);
        memory.clear();
        frameCamera();
        pos = null;
        data = null;
    }


    // -------------------------------------------------------
    // UserInterface


    function UserInterface(scene) {
        this.isShowMenuMain = false;
        this.isShowMenuGenerator = false;
        this.isShowMenuVoxelizer = false;
        this.isShowMenuSymmetry = false;
        this.isShowMenuBakery = false;
        this.isShowMenuLayer = false;
        this.isMinimal = false;
        this.isShowGrid = true;
        this.isShowShadowCatcher = true;
        this.isShowBbox = false;
        this.domMenu = document.getElementsByClassName('menu');
        this.domAxisViewItems = document.querySelectorAll('#axisview li');
        this.domColorPicker = document.getElementById('inputcolor');
        this.domHelp = document.getElementById('help');
        this.domTooltip = document.getElementsByClassName('tooltip');
        this.domNotifier = document.getElementById('notifier');
        this.domFps = document.getElementById('info').children[0];
        this.domVox = document.getElementById('info').children[1];
        this.domBak = document.getElementById('info').children[2];
        let xOffset = 0, yOffset = 0; // hover

        this.init = function() {
            this.initTooltips();

            this.domColorPicker.addEventListener('input', function (ev) {
                currentColor = this.value.toUpperCase();
                uix.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
            }, false);
        }

        this.update = function() {
            scene.getNodeByName("shadowcatcher").isVisible = this.isShowShadowCatcher;
            helper.workPlane.isVisible = this.isShowGrid;
            helper.gridPlane.isVisible = this.isShowGrid;
            builder.SPS.mesh.showBoundingBox = this.isShowBbox;
        }

        this.toggleGrid = function() {
            this.isShowGrid = !this.isShowGrid;
            this.update();
        }

        this.toggleShadowCatcher = function() {
            this.isShowShadowCatcher = !this.isShowShadowCatcher;
            this.update();
        }

        this.toggleBoundingBox = function() {
            this.isShowBbox = !this.isShowBbox;
            this.update();
        }

        this.clearAllToggles = function() {
            this.isShowGrid = true;
            this.isShowShadowCatcher = true;
            this.isShowBbox = false;
            this.update();
        }

        this.updateStatus = function() {
            this.domVox.innerHTML = builder.voxels.length;
            this.domBak.innerHTML = bakery.meshes.length;
        }

        this.notification = function(txt) {
            this.domNotifier.innerHTML = txt.toUpperCase();
            this.domNotifier.style.marginLeft = -(this.domNotifier.getBoundingClientRect().width/2) + 'px';
            this.domNotifier.classList.toggle('fade');
            setTimeout(function() {
                ui.domNotifier.classList.toggle('fade');
            }, 4000);
        }
        
        this.toggleMenuMain = function() {
            this.isShowMenuMain = !this.isShowMenuMain;
            if (!this.isShowMenuMain) {
                document.getElementById('menumain').style.transform = 'translate(200px, 0)';
            } else {
                document.getElementById('menumain').style.transform = 'translate(0, 0)';
            }
        }

        this.toggleMenuGenerator = function() {
            this.isShowMenuGenerator = !this.isShowMenuGenerator;
            if (!this.isShowMenuGenerator) {
                document.getElementById('menugenerator').style.transform = 'translate(200px, 0)';
            } else {
                document.getElementById('menugenerator').style.transform = 'translate(0, 0)';
            }
        }

        this.toggleMenuVoxelizer = function() {
            this.isShowMenuVoxelizer = !this.isShowMenuVoxelizer;
            if (!this.isShowMenuVoxelizer) {
                document.getElementById('menuvoxelizer').style.transform = 'translate(200px, 0)';
            } else {
                document.getElementById('menuvoxelizer').style.transform = 'translate(0, 0)';
            }
        }

        this.toggleMenuSymmetry = function() {
            this.isShowMenuSymmetry = !this.isShowMenuSymmetry;
            if (!this.isShowMenuSymmetry) {
                document.getElementById('menusymmetry').style.transform = 'translate(200px, 0)';
            } else {
                document.getElementById('menusymmetry').style.transform = 'translate(0, 0)';
            }
        }

        this.toggleMenuBakery = function() {
            this.isShowMenuBakery = !this.isShowMenuBakery;
            if (!this.isShowMenuBakery) {
                document.getElementById('menubakery').style.transform = 'translate(200px, 0)';
            } else {
                document.getElementById('menubakery').style.transform = 'translate(0, 0)';
            }
        }

        this.toggleMenuLayer = function() {
            this.isShowMenuLayer = !this.isShowMenuLayer;
            if (!this.isShowMenuLayer) {
                document.getElementById('menulayer').style.transform = 'translate(-200px, 0)';
            } else {
                document.getElementById('menulayer').style.transform = 'translate(0, 0)';
            }
        }

        this.buttonToggleHighQuality = function(btn) {
            if (btn.classList.contains("toggle_hq"))
                btn.classList.remove("toggle_hq");
            else
                btn.classList.add("toggle_hq");
        }

        this.buttonToggleAxisView = function(li) {
            if (li.classList.contains("toggle_axisview"))
                li.classList.remove("toggle_axisview");
            else
                li.classList.add("toggle_axisview");
        }

        this.clearAllButtons = function() {
            for (let i of document.querySelectorAll('li')) {
                i.classList.remove("toggle_hq");
                i.classList.remove("toggle_axisview");
            }
        }

        this.initTooltips = function() {
            for (let i = 0; i < this.domTooltip.length; i++) { // register all tooltips
                this.domTooltip[i].parentElement.addEventListener("pointerdown", function() { // mobile
                    ui.domHelp.firstChild.innerHTML = ui.domTooltip[i].innerHTML;
                }, false);
                this.domTooltip[i].parentElement.addEventListener("pointermove", function() { // desktop
                    ui.domHelp.firstChild.innerHTML = ui.domTooltip[i].innerHTML;
                }, false);
            }
        }

        this.toggleTooltips = function() {
            if (ui.domHelp.style.bottom == '2px') {
                ui.domHelp.style.bottom = '-1000px';
            } else {
                ui.domHelp.style.bottom = '2px';
            }
        }

        this.toggleMinimalInterface = function() {
            if (this.isMinimal) {
                document.getElementById('toolbar_R').style.display = 'unset';
                document.getElementById('toolbar_C').style.display = 'unset';
                document.getElementById('help').style.display = 'unset';
                document.getElementById('helpbtn').style.display = 'unset';
                document.getElementById('info').style.display = 'unset';
                for (let i = 0; i < this.domAxisViewItems.length; i++) // toggle AxisView childs
                    this.domAxisViewItems[i].style.display = 'unset';
                for (let i = 0; i < this.domMenu.length; i++)
                    this.domMenu[i].style.display = 'unset';
                this.isMinimal = false;
            } else {
                document.getElementById('toolbar_R').style.display = 'none';
                document.getElementById('toolbar_C').style.display = 'none';
                document.getElementById('help').style.display = 'none';
                document.getElementById('helpbtn').style.display = 'none';
                document.getElementById('info').style.display = 'none';
                for (let i = 0; i < this.domAxisViewItems.length; i++)
                    this.domAxisViewItems[i].style.display = 'none';
                for (let i = 0; i < this.domMenu.length; i++)
                    this.domMenu[i].style.display = 'none';
                this.isMinimal = true;
            }
        }

        this.toggleDebugMode = function() {
            if (scene.debugLayer.isVisible()) {
                scene.debugLayer.hide();
                document.getElementById('colorpicker').style.display = 'unset';
                document.getElementById('toolbar_R').style.display = 'unset';
                document.getElementById('toolbar_L').style.display = 'unset';
                document.getElementById('toolbar_C').style.display = 'unset';
                document.getElementById('layers').style.display = 'unset';
                document.getElementById('hover').style.display = 'unset';
                document.getElementById('help').style.display = 'unset';
                document.getElementById('helpbtn').style.display = 'unset';
                document.getElementById('info').style.display = 'unset';
                for (let i = 0; i < this.domAxisViewItems.length; i++) // toggle AxisView childs
                    this.domAxisViewItems[i].style.display = 'unset';
                for (let i = 0; i < this.domMenu.length; i++)
                    this.domMenu[i].style.display = 'unset';
                uix.colorPicker.isVisible = true;
            } else {
                scene.debugLayer.show();
                document.getElementById('colorpicker').style.display = 'none';
                document.getElementById('toolbar_R').style.display = 'none';
                document.getElementById('toolbar_L').style.display = 'none';
                document.getElementById('toolbar_C').style.display = 'none';
                document.getElementById('layers').style.display = 'none';
                document.getElementById('hover').style.display = 'none';
                document.getElementById('help').style.display = 'none';
                document.getElementById('helpbtn').style.display = 'none';
                document.getElementById('info').style.display = 'none';
                for (let i = 0; i < this.domAxisViewItems.length - 1; i++) // -1 keep debug button
                    this.domAxisViewItems[i].style.display = 'none';
                for (let i = 0; i < this.domMenu.length; i++)
                    this.domMenu[i].style.display = 'none';
                uix.colorPicker.isVisible = false;
            }
        }

        this.dragElement = function(elem) { // make a div draggable,
            let active = false;             // elem is a move handle and elem.parentElement
            let currentX, currentY, initialX, initialY; // is our movable div

            // prevent fast-dragging problem with background elements
            document.body.addEventListener("mousedown", dragStart, false);
            document.body.addEventListener("mouseup", dragEnd, false);
            document.body.addEventListener("mousemove", drag, false);
            document.body.addEventListener("touchstart", dragStart, false);
            document.body.addEventListener("touchend", dragEnd, false);
            document.body.addEventListener("touchmove", drag, false);
            function dragStart(e) {
                if (e.type === "touchstart") {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }
                if (e.target === elem) active = true;
            }
            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                active = false;
                document.body.removeEventListener("mousedown", dragStart, false);
                document.body.removeEventListener("mouseup", dragEnd, false);
                document.body.removeEventListener("mousemove", drag, false);
                document.body.removeEventListener("touchstart", dragStart, false);
                document.body.removeEventListener("touchend", dragEnd, false);
                document.body.removeEventListener("touchmove", drag, false);
            }
            function drag(e) {
                if (active) {
                    if (e.type === "touchmove") {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, elem.parentElement);
                }
            }
            function setTranslate(xPos, yPos, el) {
                el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // UserInterfaceAdvanced


    function UserInterfaceAdvanced(scene) {
        this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", {}, scene);
        this.colorPicker = undefined;
        this.gizmo = null;

        this.init = function() {
            this.createAdvancedColorPicker();
        }

        this.createAdvancedColorPicker = function() {
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "105px";
            panel.height = "105px";
            panel.isVertical = true;
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            this.advancedTexture.addControl(panel);  

            this.colorPicker = new BABYLON.GUI.ColorPicker();
            this.colorPicker.value = BABYLON.Color3.FromHexString(currentColor);
            this.colorPicker.height = "100px";
            this.colorPicker.width = "100px";
            this.colorPicker.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            this.colorPicker.verticalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_TOP;
            this.colorPicker.onValueChangedObservable.add(function(value) { //color3
                currentColor = rgbFloatToHex(value.r, value.g, value.b);
                ui.domColorPicker.value = currentColor;
            });
            panel.addControl(this.colorPicker);
        }

        this.bindGizmo = function(meshes) {
            this.unbindGizmo();
            this.gizmo = new BABYLON.GizmoManager(scene, 2, new BABYLON.UtilityLayerRenderer(scene));
            this.gizmo.positionGizmoEnabled = true;
            this.gizmo.rotationGizmoEnabled = true;
            this.gizmo.scaleGizmoEnabled = false;
            this.gizmo.usePointerToAttachGizmos = true;
            this.gizmo.clearGizmoOnEmptyPointerEvent = false; // handled manually on tool.handleToolDown()

            this.gizmo.gizmos.positionGizmo.scaleRatio = 1.0;
            this.gizmo.gizmos.positionGizmo.snapDistance  = 0.5;
            this.gizmo.gizmos.positionGizmo.planarGizmoEnabled = true;
            [this.gizmo.gizmos.positionGizmo.xPlaneGizmo,
             this.gizmo.gizmos.positionGizmo.yPlaneGizmo,
             this.gizmo.gizmos.positionGizmo.zPlaneGizmo].forEach((gizmo) => {
                gizmo.scaleRatio = 0.6;
                gizmo.snapDistance = 0.1;
            });
            this.gizmo.gizmos.rotationGizmo.scaleRatio = 0.6;
            this.gizmo.gizmos.rotationGizmo.snapDistance = 0.1;

            this.gizmo.attachableMeshes = meshes;
            this.gizmo.onAttachedToMeshObservable.add((mesh) => {
                bakery.selectMesh(mesh);
            });
        }

        this.unbindGizmo = function() {
            if (this.gizmo) {
                this.gizmo.dispose();
                this.gizmo = null;
            }
        }

        this.init();
    }


    // -------------------------------------------------------
    // Events


    scene.onPointerObservable.add((pointerInfo) => {
        switch (pointerInfo.type) {
            case BABYLON.PointerEventTypes.POINTERDOWN:
                tool.handleToolDown(pointerInfo.event);
                break;
            case BABYLON.PointerEventTypes.POINTERUP:
                tool.handleToolUp(pointerInfo.event);
                break;
            case BABYLON.PointerEventTypes.POINTERMOVE:
                tool.handleToolMove(pointerInfo.event);
                break;
        }
    });

    canvas.addEventListener("keyup", function (ev) {
        //console.log(ev.key);
        switch (ev.key) {
            case 'a':
                tool.toolSelector('add');
                break;
            case 't':
                tool.toolSelector('transform');
                break;
            case 'r':
                tool.toolSelector('remove');
                break;
            case 'p':
                tool.toolSelector('paint');
                break;
            case 'b':
                tool.toolSelector('bucket');
                break;
            case 'e':
                tool.toolSelector('eyedrop');
                break;
            case 'f':
                frameCamera();
                break;
            case 'o':
                ui.toggleDebugMode();
                break;
            case '`':
                ui.toggleMinimalInterface();
                break;
            case ' ': // space
                tool.toolSelector('camera');
                break;
        }
        if (ev.ctrlKey && ev.key === 'z') memory.undo();
        if (ev.ctrlKey && ev.key === 'x') memory.redo();
        // bind memory steps to keys 0-9
        if ([0,1,2,3,4,5,6,7,8,9].includes(parseInt(ev.key))) {
            memory.loadStep(parseInt(ev.key));
        }
    }, false);

    function fileHandler(file) {
        const ext = file.name.split('.').pop().toLowerCase(); //ext|exts
        const url = URL.createObjectURL(file);
        const reader = new FileReader();
        reader.onload = function() {
            if (ext === 'vox') loadProject(reader.result);
            if (ext === 'obj') importMesh(url, '.'+ext);
            if (['jpg','png'].includes(ext)) voxelizer.voxelize2D(reader.result);
            URL.revokeObjectURL(url);
        }
        if (ext === 'vox') {
            reader.readAsText(file);
        } else {
            reader.readAsDataURL(file);
        }
    }

    function dropHandler(ev) {
        ev.preventDefault();
        fileHandler(ev.dataTransfer.files[0]);
    }
    function dragHandler(ev) {
        ev.preventDefault();
    }
    function dragLeaveHandler(ev) {
        ev.preventDefault();
    }

    document.getElementById('openfile_vox').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_obj').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    document.getElementById('openfile_img').addEventListener("change", function (ev) {
        if (ev.target.files.length > 0)
            fileHandler(ev.target.files[0]);
    }, false);

    window.addEventListener("resize", function (ev) { 
        engine.resize();
        updateAxisViewViewport();
    }, false);


    // -------------------------------------------------------
    // Utils


    function animator(target, property, from, to, fps=10, totalFrames=10) {
        BABYLON.Animation.CreateAndStartAnimation('animator',
            target, property, fps, totalFrames,
            from, to, 0, easingFunction, null);  // disposeOnEnd is true
    }

    function frameCamera(radius = 1.5, mesh = builder.SPS.mesh) {
        scene.activeCamera.useFramingBehavior = true;
        scene.activeCamera.framingBehavior.radiusScale = radius;
        scene.activeCamera.setTarget(mesh);
        scene.activeCamera.target = new BABYLON.Vector3(0,0.01,0); // workaround: prevent panning-lock in certain conditions
        setCamera(scene.activeCamera); // need to re-apply settings
        scene.activeCamera.useFramingBehavior = false;
    }

    function setCamera(camera) {
        camera.useFramingBehavior = true;
        camera.framingBehavior.zoomStopsAnimation = true;
        camera.framingBehavior.radiusScale = 1.5;
        camera.framingBehavior.positionScale = 0.5;
        camera.framingBehavior.defaultElevation = 0.3;
        camera.framingBehavior.elevationReturnTime = 1500;
        camera.framingBehavior.elevationReturnWaitTime = 1000;
        camera.framingBehavior.framingTime = 1000;
        camera.lowerRadiusLimit = 5;
        camera.upperRadiusLimit = 500;
        camera.wheelPrecision = 10;
        camera.panningSensibility = 300;
        camera.pinchPrecision = 100;
    }

    function toggleCameraAutoRotation() {
        scene.activeCamera.useAutoRotationBehavior = !scene.activeCamera.useAutoRotationBehavior;
        if (scene.activeCamera.useAutoRotationBehavior) {
            scene.activeCamera.autoRotationBehavior.idleRotationSpeed = 0.1;
            scene.activeCamera.autoRotationBehavior.idleRotationWaitTime = 1;
            scene.activeCamera.autoRotationBehavior.idleRotationSpinupTime = 1;
        }
    }
        
    function updateShadowMap() {
        scene.lights[1].getShadowGenerator().getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }

    function updateViewport(w, h, bottom, right) {
        return new BABYLON.Viewport(1 - (w + right) / canvas.width, 1 - (bottom + canvas.height) / canvas.height,   w / canvas.width, h / canvas.height);
    }

    function updateAxisViewViewport() {
        sceneAxisView.activeCamera.viewport = updateViewport(70, 70, 0, 0);
    }

    function setLightPositionByAngle(light, angle, distance, height) {
        const x = Math.cos(angle * Math.PI / 180) * distance;
        const z = Math.sin(angle * Math.PI / 180) * distance;
        light.position = new BABYLON.Vector3(x, height, z);
        light.setDirectionToTarget(BABYLON.Vector3.Zero());
    }

    function updateLightAngles(value) {
        setLightPositionByAngle(scene.lights[1], parseInt(value), 50, 100);
        updateShadowMap();
    }

    function getMeshSize(bounds) {
        const size = new BABYLON.Vector3();
        size.x = Math.abs(bounds.minimum.x - bounds.maximum.x);
        size.y = Math.abs(bounds.minimum.y - bounds.maximum.y);
        size.z = Math.abs(bounds.minimum.z - bounds.maximum.z);
        return size;
    }

    function normalizeVoxelPositions(isRecordMem) {
        const bounds = builder.SPS.mesh.getBoundingInfo();
        const size = getMeshSize(bounds);
        const center = bounds.boundingBox.center;
        const nX = -bounds.maximum.x + (size.x / 2);
        const nY = ((size.y / 2) - center.y) - 0.5;
        const nZ = -bounds.maximum.z + (size.z / 2);
        let transMatrix = null;
        let position = null;
        for (let i = 0; i < builder.voxels.length; i++) {
            transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
            position = BABYLON.Vector3.TransformCoordinates(builder.voxels[i].position, transMatrix);
            builder.setVoxelPosition(i, position);
        }
        builder.createSPS();
        transMatrix = null;
        position = null;
        if (isRecordMem) {
            if (!builder.SPS.mesh.getBoundingInfo().boundingBox.center.equals(center)) {
                memory.record(); // record on changes
            }
        }
    }

    function normalizeMesh(mesh, scale) {
        const bounds = mesh.getBoundingInfo();
        const size = getMeshSize(bounds);
        // normalize scale
        const scaleFactor = Math.min(scale / size.x, scale / size.y, scale / size.z);
        let scaleMatrix = BABYLON.Matrix.Scaling(scaleFactor, scaleFactor, scaleFactor);
        // center mesh and drop to floor
        const nX = -bounds.maximum.x + (size.x / 2);
        const nY = (size.y / 2) - bounds.boundingBox.center.y;
        const nZ = -bounds.maximum.z + (size.z / 2);
        let transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
        // bake matrices
        let matrix = transMatrix.multiply(scaleMatrix);
        mesh.bakeTransformIntoVertices(matrix);
        scaleMatrix = null;
        transMatrix = null;
        matrix = null;
    }

    function optimize() {
        engine.displayLoadingUI();
        scene.activeCamera.detachControl(canvas);
        layer.setAllLayersVisible();
        memory.clear();
        engine.clearInternalTexturesCache();
        scene.cleanCachedTextureBuffer();
        BABYLON.Tools.ClearLogCache();
        BABYLON.SceneOptimizer.OptimizeAsync(scene, BABYLON.SceneOptimizerOptions.LowDegradationAllowed(),
        function() {
            scene.activeCamera.attachControl(canvas, true);
            engine.hideLoadingUI();
            ui.notification('optimized');
        }, function() {
            scene.activeCamera.attachControl(canvas, true);
            engine.hideLoadingUI();
            ui.notification('optimization failed');
        });
    }

    function downloadText(txt, filename) {
        const blob = new Blob([ txt ], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        delete a;
    }

    function loadFile(url) {
        engine.displayLoadingUI();
        fetch(url).then(
            function(response) {
                if (response.status !== 200) {
                    console.log('loadFile', response.status);
                    engine.hideLoadingUI();
                    return;
                }
                response.text().then(function(data) {
                    loadProject(data);
                    engine.hideLoadingUI();
                });
            }
        ).catch(function(err) {
            console.log('loadFile', err);
            engine.hideLoadingUI();
        });
    }

    function toggleFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            document.body.requestFullscreen();
        }
    }

    function isMobileDevice() {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
            || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
            return true;
        }
        return false;
    }

    function aspectRatioFit(srcW, srcH, maxW, maxH) {
        const ratio = Math.min(maxW / srcW, maxH / srcH);
        return { width: srcW * ratio, height: srcH * ratio };
    }

    function hexToRgbFloat(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: (parseInt(result[1], 16) / 255).toFixed(3),
            g: (parseInt(result[2], 16) / 255).toFixed(3),
            b: (parseInt(result[3], 16) / 255).toFixed(3)
        } : null;
    }

    function rgbFloatToHex(r, g, b) {
        const hr = Math.max(0, Math.min(255, Math.round(r * 255))).toString(16);
        const hg = Math.max(0, Math.min(255, Math.round(g * 255))).toString(16);
        const hb = Math.max(0, Math.min(255, Math.round(b * 255))).toString(16);
        return ("#" +
            (hr.length<2?"0":"") + hr +
            (hg.length<2?"0":"") + hg +
            (hb.length<2?"0":"") + hb).toUpperCase();
    }

    function rgbIntToHex(r, g, b) {
        return '#' + (0x1000000 + b | (g << 8) | (r << 16)).toString(16).slice(1).toUpperCase();
    }

    function parseBool(val) {
        return val === true || val === "true";
    }

    // source: https://doc.babylonjs.com/toolsAndResources/utilities/SurfaceMeshPoints
    function getRandomPointsOnMeshSurface(mesh, pointDensity) {
        let positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        let indices = mesh.getIndices();
        
        let index = 0;
        let id0 = 0;
        let id1 = 0; 
        let id2 = 0;
        let v0X = 0;
        let v0Y = 0;
        let v0Z = 0;
        let v1X = 0;
        let v1Y = 0
        let v1Z = 0;
        let v2X = 0;
        let v2Y = 0;
        let v2Z = 0;
        let vertex0 = BABYLON.Vector3.Zero();
        let vertex1 = BABYLON.Vector3.Zero();
        let vertex2 = BABYLON.Vector3.Zero();
        let vec0 = BABYLON.Vector3.Zero();
        let vec1 = BABYLON.Vector3.Zero();
        let vec2 = BABYLON.Vector3.Zero();

        let a = 0; // length of side of triangle
        let b = 0; // length of side of triangle
        let c = 0; // length of side of triangle
        let p = 0; // perimeter of triangle
        let area = 0;
        let nbPoints = 0; // nbPoints per triangle
            
        let lamda = 0;  
        let mu = 0;
        let facetPoint = null;
        let points = [];
        
        for (let index = 0; index < indices.length / 3; index++) {                
            id0 = indices[3 * index];
            id1 = indices[3 * index + 1]; 
            id2 = indices[3 * index + 2];        
            v0X = positions[3 * id0];
            v0Y = positions[3 * id0 + 1];
            v0Z = positions[3 * id0 + 2];
            v1X = positions[3 * id1];
            v1Y = positions[3 * id1 + 1];
            v1Z = positions[3 * id1 + 2];
            v2X = positions[3 * id2];
            v2Y = positions[3 * id2 + 1];
            v2Z = positions[3 * id2 + 2];
            vertex0.set(v0X, v0Y, v0Z);
            vertex1.set(v1X, v1Y, v1Z);
            vertex2.set(v2X, v2Y, v2Z);
            vertex1.subtractToRef(vertex0, vec0);
            vertex2.subtractToRef(vertex1, vec1);
            vertex2.subtractToRef(vertex0, vec2);
            a = vec0.length();
            b = vec1.length();
            c = vec2.length();
            p = (a + b + c) / 2;        
            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
            nbPoints = Math.round(pointDensity * area);
            for (let i = 0; i < nbPoints; i++) { // form a point inside the facet v0, v1, v2;
                lamda = BABYLON.Scalar.RandomRange(0, 1);   
                mu = BABYLON.Scalar.RandomRange(0, 1);
                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));
                points.push(facetPoint);
            }   
        }
        positions = null;
        indices = null;
        return points;
    }

    // source: https://gist.github.com/banksean/304522
    function ClassicalNoise() {
        this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], 
                     [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], 
                     [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
        this.p = [];
        for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(Math.random()*256);
        }
        // To remove the need for index wrapping,
        this.perm = []; // double the permutation table length
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
        }
        this.dot = function(g, x, y, z) { 
            return g[0]*x + g[1]*y + g[2]*z; 
        }
        this.mix = function(a, b, t) { 
            return (1.0-t)*a + t*b; 
        }
        this.fade = function(t) { 
            return t*t*t*(t*(t*6.0-15.0)+10.0); 
        }
        // Classic Perlin noise, 3D version
        this.noise = function(x, y, z) { 
            // Find unit grid cell containing point 
            let X = Math.floor(x); 
            let Y = Math.floor(y); 
            let Z = Math.floor(z); 
            // Get relative xyz coordinates of point within that cell 
            x = x - X; 
            y = y - Y; 
            z = z - Z; 
            // Wrap the integer cells at 255 (smaller integer period can be introduced here) 
            X = X & 255; 
            Y = Y & 255; 
            Z = Z & 255;
            // Calculate a set of eight hashed gradient indices 
            const gi000 = this.perm[X+this.perm[Y+this.perm[Z]]] % 12; 
            const gi001 = this.perm[X+this.perm[Y+this.perm[Z+1]]] % 12; 
            const gi010 = this.perm[X+this.perm[Y+1+this.perm[Z]]] % 12; 
            const gi011 = this.perm[X+this.perm[Y+1+this.perm[Z+1]]] % 12; 
            const gi100 = this.perm[X+1+this.perm[Y+this.perm[Z]]] % 12; 
            const gi101 = this.perm[X+1+this.perm[Y+this.perm[Z+1]]] % 12; 
            const gi110 = this.perm[X+1+this.perm[Y+1+this.perm[Z]]] % 12; 
            const gi111 = this.perm[X+1+this.perm[Y+1+this.perm[Z+1]]] % 12; 
            // Calculate noise contributions from each of the eight corners 
            const n000= this.dot(this.grad3[gi000], x, y, z); 
            const n100= this.dot(this.grad3[gi100], x-1, y, z); 
            const n010= this.dot(this.grad3[gi010], x, y-1, z); 
            const n110= this.dot(this.grad3[gi110], x-1, y-1, z); 
            const n001= this.dot(this.grad3[gi001], x, y, z-1); 
            const n101= this.dot(this.grad3[gi101], x-1, y, z-1); 
            const n011= this.dot(this.grad3[gi011], x, y-1, z-1); 
            const n111= this.dot(this.grad3[gi111], x-1, y-1, z-1); 
            // Compute the fade curve value for each of x, y, z 
            const u = this.fade(x); 
            const v = this.fade(y); 
            const w = this.fade(z); 
            // Interpolate along x the contributions from each of the corners 
            const nx00 = this.mix(n000, n100, u); 
            const nx01 = this.mix(n001, n101, u); 
            const nx10 = this.mix(n010, n110, u); 
            const nx11 = this.mix(n011, n111, u); 
            // Interpolate the four results along y 
            const nxy0 = this.mix(nx00, nx10, v); 
            const nxy1 = this.mix(nx01, nx11, v); 
            // Interpolate the two last results along z 
            return this.mix(nxy0, nxy1, w); // nxyz
        }
    }


    // -------------------------------------------------------
    // Startup


    loadProject(`-1,0,-1,#3876C0,true
                -1,0,0,#3876C0,true
                -1,0,1,#3876C0,true
                -1,1,-1,#33D7BE,true
                -1,1,0,#33D7BE,true
                -1,1,1,#33D7BE,true
                -1,2,-1,#B262A0,true
                0,0,-1,#3876C0,true
                0,0,0,#3876C0,true
                0,0,1,#3876C0,true
                0,1,-1,#33D7BE,true
                0,1,0,#3876C0,true
                0,1,1,#33D7BE,true
                1,0,-1,#3876C0,true
                1,0,0,#3876C0,true
                1,0,1,#3876C0,true
                1,1,-1,#33D7BE,true
                1,1,0,#33D7BE,true
                1,1,1,#33D7BE,true
                1,2,-1,#B262A0,true
                1,2,1,#B262A0,true
                -1,0,2,#3876C0,true
                0,0,2,#33D7BE,true
                1,0,2,#3876C0,true
                2,0,1,#3876C0,true
                2,0,0,#33D7BE,true
                2,0,-1,#3876C0,true
                1,0,-2,#3876C0,true
                0,0,-2,#33D7BE,true
                -1,0,-2,#3876C0,true
                -2,0,-1,#3876C0,true
                -2,0,0,#33D7BE,true
                -2,0,1,#3876C0,true
                -1,2,1,#B262A0,true
                0,3,0,#D08412,false`);

</script>
</html>
